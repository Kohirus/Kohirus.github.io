<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Nginx内存池源码剖析</title>
    <url>/2022/12/20/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p>Nginx 内存池源码剖析</p>

</blockquote>
<p><a href="http://nginx.org/">Nginx</a> 源码版本: 1.13.1</p>
<p>Nginx 内存池的定义主要位于如下两个文件中：</p>
<ul>
<li>ngx_palloc.h</li>
<li>ngx_palloc.c</li>
</ul>
<p>首先是几个重要的宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NGX_MAX_ALLOC_FROM_POOL  (ngx_pagesize - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NGX_DEFAULT_POOL_SIZE    (16 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NGX_POOL_ALIGNMENT       16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NGX_MIN_POOL_SIZE                                                     \</span></span><br><span class="line"><span class="meta">    ngx_align((sizeof(ngx_pool_t) + 2 * sizeof(ngx_pool_large_t)),            \</span></span><br><span class="line"><span class="meta">              NGX_POOL_ALIGNMENT)</span></span><br></pre></td></tr></table></figure>
<p>它们的含义分别如下：</p>
<ul>
<li><code>NGX_MAX_ALLOC_FROM_POOL</code>:
最多可以从内存池中取得的大小，在 x86 机器上为 4095</li>
<li><code>NGX_DEFAULT_POOL_SIZE</code>: 默认的内存池大小，16K</li>
<li><code>NGX_POOL_ALIGNMENT</code>: 内存池字节对齐相关</li>
<li><code>NGX_MIN_POOL_SIZE</code>: 最小的内存池大小</li>
</ul>
<p>其中的 <code>ngx_align</code> 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_align(d, a)     (((d) + (a - 1)) &amp; ~(a - 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_align_ptr(p, a)                                                   \</span></span><br><span class="line"><span class="meta">    (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) &amp; ~((uintptr_t) a - 1))</span></span><br></pre></td></tr></table></figure>
<p>上述两个宏函数的作用分别是：(1) 将数值 d 调整到 a 的临近倍数；(2)
将指针 p 调整到 a 的临近倍数。类似于 <code>SGI STL</code>
中的位运算设计。</p>
<p>然后介绍几个重要的数据类型，它们被用来表示内存池的头部信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u_char               *last;</span><br><span class="line">    u_char               *end;</span><br><span class="line">    <span class="type">ngx_pool_t</span>           *next;</span><br><span class="line">    <span class="type">ngx_uint_t</span>            failed;</span><br><span class="line">&#125; <span class="type">ngx_pool_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> &#123;</span></span><br><span class="line">    <span class="type">ngx_pool_data_t</span>       d;</span><br><span class="line">    <span class="type">size_t</span>                max;</span><br><span class="line">    <span class="type">ngx_pool_t</span>           *current;</span><br><span class="line">    <span class="type">ngx_chain_t</span>          *chain;</span><br><span class="line">    <span class="type">ngx_pool_large_t</span>     *large;</span><br><span class="line">    <span class="type">ngx_pool_cleanup_t</span>   *cleanup;</span><br><span class="line">    <span class="type">ngx_log_t</span>            *<span class="built_in">log</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> <span class="title">ngx_pool_t</span>;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="/images/NginxMemoryPool/ngx_pool_s.png" style="zoom:70%"/></p>
<h1 id="调整内存边界">1. 调整内存边界</h1>
<p>函数 <code>ngx_memalign</code> 是一个调整内存对齐的函数，分为 Windows
平台和 Unix 两种平台实现，其中 Unix 平台下的实现如下，通过两个宏
<code>NGX_HAVE_POSIX_MEMALIGN</code> 和 <code>NGX_HAVE_MEMALIGN</code>
进行控制：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Linux has memalign() or posix_memalign()</span></span><br><span class="line"><span class="comment"> * Solaris has memalign()</span></span><br><span class="line"><span class="comment"> * FreeBSD 7.0 has posix_memalign(), besides, early version&#x27;s malloc()</span></span><br><span class="line"><span class="comment"> * aligns allocations bigger than page size at the page boundary</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_HAVE_POSIX_MEMALIGN || NGX_HAVE_MEMALIGN)</span></span><br><span class="line">	<span class="type">void</span> *<span class="title function_">ngx_memalign</span><span class="params">(<span class="type">size_t</span> alignment, <span class="type">size_t</span> size, <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ngx_memalign(alignment, size, log)  ngx_alloc(size, log)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>其中的 <code>ngx_alloc</code>
函数实现如下，可以看到，其内部实现实际上调用的就是 <code>malloc</code>
函数来分配动态内存：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">ngx_alloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span> &#123;</span><br><span class="line">    <span class="type">void</span>  *p;</span><br><span class="line">    p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">&quot;malloc(%uz) failed&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, <span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;malloc: %p:%uz&quot;</span>, p, size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果定义了 <code>NGX_HAVE_POSIX_MEMALIGN</code>
宏，则会调用如下函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">ngx_memalign</span><span class="params">(<span class="type">size_t</span> alignment, <span class="type">size_t</span> size, <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span> &#123;</span><br><span class="line">    <span class="type">void</span>  *p;</span><br><span class="line">    <span class="type">int</span>    err;</span><br><span class="line">    err = posix_memalign(&amp;p, alignment, size);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, err, <span class="string">&quot;posix_memalign(%uz, %uz) failed&quot;</span>, alignment, size);</span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ngx_log_debug3(NGX_LOG_DEBUG_ALLOC, <span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;posix_memalign: %p:%uz @%uz&quot;</span>, p, size, alignment);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果定义了 <code>NGX_HAVE_MEMALIGN</code> 宏，则会调用如下函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">ngx_memalign</span><span class="params">(<span class="type">size_t</span> alignment, <span class="type">size_t</span> size, <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span> &#123;</span><br><span class="line">    <span class="type">void</span>  *p;</span><br><span class="line">    p = memalign(alignment, size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">&quot;memalign(%uz, %uz) failed&quot;</span>, alignment, size);</span><br><span class="line">    &#125;</span><br><span class="line">    ngx_log_debug3(NGX_LOG_DEBUG_ALLOC, <span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;memalign: %p:%uz @%uz&quot;</span>, p, size, alignment);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上两个函数会根据传入的 <code>alignment</code>
函数参数进行字节对齐。</p>
<h1 id="创建内存池">2. 创建内存池</h1>
<p>首先来看一下函数
<code>ngx_create_pool</code>，其作用是创建一个内存池，其源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ngx_pool_t</span>* <span class="title function_">ngx_create_pool</span><span class="params">(<span class="type">size_t</span> size, <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span> &#123;</span><br><span class="line">    <span class="type">ngx_pool_t</span>  *p;</span><br><span class="line">    </span><br><span class="line">    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, <span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p-&gt;d.last = (u_char *) p + <span class="keyword">sizeof</span>(<span class="type">ngx_pool_t</span>);</span><br><span class="line">    p-&gt;d.end = (u_char *) p + size;</span><br><span class="line">    p-&gt;d.next = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    size = size - <span class="keyword">sizeof</span>(<span class="type">ngx_pool_t</span>);</span><br><span class="line">    p-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line">    </span><br><span class="line">    p-&gt;current = p;</span><br><span class="line">    p-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;cleanup = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;<span class="built_in">log</span> = <span class="built_in">log</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数根据用户传入的 <code>size</code> 大小来开辟内存池，首先调用了
<code>ngx_memalign</code>
函数来进行字节对齐和动态内存分配，字节对齐使用的是上方的
<code>NGX_POOL_ALIGNMENT</code>
宏。同时可以根据不同的平台所定义的宏来调用不同的内存分配函数，如果没有相关的宏，则实质调用的是
<code>malloc</code> 函数来进行动态内存分配。</p>
<p>然后，分别初始化
<code>d.last</code>、<code>d.end</code>、<code>d.next</code> 和
<code>d.failed</code>，可以看出来，<code>d.last</code>
指向了内存池头部信息的末尾位置，<code>d.end</code>
则指向了内存池的最末尾位置，如下图所示：</p>
<p><img data-src="/images/NginxMemoryPool/ngx_struct_1.png" style="zoom:60%"/></p>
<p>然后通过用 <code>size</code>
减去内存池头部数据的长度，得到内存池的可用空间大小。而 <code>max</code>
则调整为 <code>size</code> 和 <code>NGX_MAX_ALLOC_FROM_POOL</code>
的最小值，保证内存池的最大容量不超过一页。然后 <code>current</code>
指针则指向了当前内存池的起始地址，示意图如下：</p>
<p><img data-src="/images/NginxMemoryPool/ngx_struct_2.png" style="zoom:60%"/></p>
<p>创建成功后，返回内存池头部地址即可。其它头部信息后面再说。</p>
<h1 id="向内存池申请内存">3. 向内存池申请内存</h1>
<p>如果需要向内存池申请内存，则可用调用如下几个函数：</p>
<p>函数 <code>ngx_palloc</code> 的作用是向内存池申请 <code>size</code>
大小的内存，同时使用字节对齐:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">ngx_palloc</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !(NGX_DEBUG_PALLOC)</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool-&gt;max) &#123;</span><br><span class="line">        <span class="keyword">return</span> ngx_palloc_small(pool, size, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ngx_palloc_large(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数 <code>ngx_pnalloc</code> 的作用是向内存池申请 <code>size</code>
大小的内存，但不使用字节对齐：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">ngx_pnalloc</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !(NGX_DEBUG_PALLOC)</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool-&gt;max) &#123;</span><br><span class="line">        <span class="keyword">return</span> ngx_palloc_small(pool, size, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ngx_palloc_large(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数 <code>ngx_pcalloc</code>
的作用是先申请内存，然后对内存块清零：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">ngx_pcalloc</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">void</span> *p;</span><br><span class="line">    p = ngx_palloc(pool, size);</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        ngx_memzero(p, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上可以看到，向内存池申请内存时，Nginx 会根据用户传入的
<code>size</code> 参数来选择调用 <code>ngx_palloc_small</code> 函数和
<code>ngx_palloc_large</code>
函数，前者用来申请小块内存，后者用来申请大块内存，可以看到，小块内存和大块内存的分界线便是头部信息中的
<code>max</code> 参数。</p>
<h1 id="申请小块内存">4. 申请小块内存</h1>
<p>如果申请的是小块内存，则调用 <code>ngx_palloc_small</code>
函数，其代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">ngx_palloc_small</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size, <span class="type">ngx_uint_t</span> align)</span> &#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="type">ngx_pool_t</span>  *p;</span><br><span class="line">    p = pool-&gt;current;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        m = p-&gt;d.last;</span><br><span class="line">        <span class="keyword">if</span> (align) &#123;</span><br><span class="line">            m = ngx_align_ptr(m, NGX_ALIGNMENT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">size_t</span>) (p-&gt;d.end - m) &gt;= size) &#123;</span><br><span class="line">            p-&gt;d.last = m + size;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;d.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p);</span><br><span class="line">    <span class="keyword">return</span> ngx_palloc_block(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在循环中，先获取了内存池头部信息的末尾位置，然后根据用户传入的
<code>align</code> 参数来确定是否调用 <code>ngx_align_ptr</code> 对
<code>d.last</code> 进行字节调整，即调整内存池头部信息的末尾位置。</p>
<p>此后，如果内存池末尾位置减去头部信息末尾位置的大小大于等于
<code>size</code>
参数，即内存池可用空间大小要大于用户需要的大小，则简单的调整
<code>d.last</code> 指针即可，这也是 Nginx 内存池分配内存快的原因。</p>
<p>而如果可用空间小于用户的需求量，那么会通过 <code>d.next</code>
指针进入下一个内存块，由于初始化时该指针为空，则会跳出循环，转而调用
<code>ngx_palloc_block</code> 函数创建一个新的内存池。</p>
<p>我们也可以根据 <code>next</code> 字段的存在大概猜到，Nginx
的小块内存采用的是链表结构。</p>
<h1 id="创建次级内存池">5. 创建次级内存池</h1>
<p>这里我暂且称 <code>ngx_palloc_block</code>
函数所创建的内存池为次级内存池，其代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">ngx_palloc_block</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="type">size_t</span>       psize;</span><br><span class="line">    <span class="type">ngx_pool_t</span>  *p, *new;</span><br><span class="line">    </span><br><span class="line">    psize = (<span class="type">size_t</span>) (pool-&gt;d.end - (u_char *) pool);</span><br><span class="line">    </span><br><span class="line">    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool-&gt;<span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    new = (<span class="type">ngx_pool_t</span> *) m;</span><br><span class="line">    </span><br><span class="line">    new-&gt;d.end = m + psize;</span><br><span class="line">    new-&gt;d.next = <span class="literal">NULL</span>;</span><br><span class="line">    new-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    m += <span class="keyword">sizeof</span>(<span class="type">ngx_pool_data_t</span>);</span><br><span class="line">    m = ngx_align_ptr(m, NGX_ALIGNMENT);</span><br><span class="line">    new-&gt;d.last = m + size;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (p = pool-&gt;current; p-&gt;d.next; p = p-&gt;d.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;d.failed++ &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            pool-&gt;current = p-&gt;d.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p-&gt;d.next = new;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数会先创建一个新的内存池，该内存池的大小与之前创建的内存池大小相同，不同的只是该次级内存池只保留有
<code>ngx_pool_data_t</code>
的相关信息。然后在这个次级内存池中取出用户需要的部分，并调整相关指针、调整边界对齐等。</p>
<p>在最后的循环中，从内存池链表的 <code>current</code>
指针开始，遍历内存池链表，如果某个内存池的 <code>failed</code> 字段比 4
大，则表明该内存池已经分配失败至少 4
次了，说明该内存池的可用空间大小已经不足以分配新的内存空间了，于是就让
<code>current</code> 指向下一个内存池节点。</p>
<p>最后将新创建的次级内存池插入到内存池链表的末尾，返回用户所需的内存空间。</p>
<p>下图为小块内存池链表的相关信息，可见，由于第一个小块内存池的
<code>failed</code> 字段为 5，则其 <code>current</code>
字段则指向了下一个 <code>failed</code> 字段不为 4
的小块内存池，各个小块内存池之间通过 next
指针形成链表形式的数据结构。同时，可以看到，除了第一个内存池之外，后面的所有次级内存池都只有
last、end、next、failed 这四个头部信息：</p>
<p><img data-src="/images/NginxMemoryPool/ngx_struct_3.png" style="zoom:60%"/></p>
<h1 id="创建大块内存">6. 创建大块内存</h1>
<p>首先来看一个关于大块内存信息的数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span>  <span class="title">ngx_pool_large_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span> &#123;</span></span><br><span class="line">    <span class="type">ngx_pool_large_t</span>     *next;</span><br><span class="line">    <span class="type">void</span>                 *alloc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中的 <code>next</code>
指针用于指向下一个大块内存池，和小块内存池一样，其也是一个链表形式的数据结构。另外的
<code>alloc</code> 参数则用于指向在堆中申请的大块内存空间。</p>
<p>如果用户需要的内存空间大于 <code>max</code> 字段，则会调用
<code>ngx_palloc_large</code> 函数来创建大块内存池，其源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">ngx_palloc_large</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">void</span>              *p;</span><br><span class="line">    <span class="type">ngx_uint_t</span>         n;</span><br><span class="line">    <span class="type">ngx_pool_large_t</span>  *large;</span><br><span class="line">    </span><br><span class="line">    p = ngx_alloc(size, pool-&gt;<span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (large = pool-&gt;large; large; large = large-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (large-&gt;alloc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n++ &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    large = ngx_palloc_small(pool, <span class="keyword">sizeof</span>(<span class="type">ngx_pool_large_t</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (large == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ngx_free(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = pool-&gt;large;</span><br><span class="line">    pool-&gt;large = large;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数先调用了 <code>ngx_alloc</code>
函数来申请堆内存，前面阅读源码我们知道，<code>ngx_alloc</code>
函数的底层就是调用的 <code>malloc</code>
函数。然后遍历大块内存池链表，如果有某个大块内存的的 <code>alloc</code>
字段为空，则让该字段指向新申请的堆内存。</p>
<p>为了效率考虑，只寻找 3
次，如果没有找到，则在小块内存池中申请一部分空间用于存放
<code>ngx_pool_large_t</code> 类型，且该结构的 <code>alloc</code>
字段指向新创建的大块堆内存，然后使用头插法放入大块内存的链表中。</p>
<p>大块内存的相关示意图如下所示：</p>
<p><img data-src="/images/NginxMemoryPool/ngx_struct_4.png" style="zoom:60%"/></p>
<h1 id="释放大块内存">7. 释放大块内存</h1>
<p>函数 <code>ngx_pfree</code> 是用来释放大块内存的，其源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ngx_int_t</span> <span class="title function_">ngx_pfree</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_pool_large_t</span>  *l;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == l-&gt;alloc) &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;free: %p&quot;</span>, l-&gt;alloc);</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = <span class="literal">NULL</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> NGX_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> NGX_DECLINED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，该函数会遍历大块内存链表，找寻要释放的大块内存，通过调用
<code>ngx_free</code>，即底层的 <code>free</code>
来释放大块内存空间。释放完成后，将 <code>alloc</code>
字段置为空，用于下次存放重新申请的大块内存。</p>
<p>注意：Nginx
内存池不存在对于小块内存的释放函数，因为从小块内存池中取出区块是通过偏移
<code>d.last</code> 指针来完成的，如果现在在小块内存池中有 3
块连续的内存：1、2、3，现在需要释放内存块 2，很显然，内存块 2
释放后还需要将内存块 1 和内存块 3 拼接在一起，并不高效。</p>
<p>如此设计的原因是因为 Nginx 的应用场景，由于 Nginx 是一个 短链接
的服务器，浏览器(即客户端)发送一个 Request 到达 Nginx
服务器并处理完成，Nginx 会给客户端返回一个 Response 响应，此时 HTTP
服务器就会主动断开 TCP 连接。即使在 HTTP 1.1 中有了 60s 的 Keep Alive
心跳时间(即返回响应后，等待 60s，如果这 60s
内客户端又发来请求，就重置这个时间，否则就主动断开连接)，在超过心跳时间之后，Nginx
就可以调用 <code>ngx_reset_pool</code>
来重置内存池，等待下一个连接的到来。</p>
<p>而如果将该内存池的分配方案应用于一个长连接的服务器，那么内存池模块会持续申请小块内存，而得不到释放，则会一直申请直到服务器资源耗尽。如果需要在长连接的服务器中使用内存池模块，那么可以使用
SGI 的二级空间配置器方案。</p>
<h1 id="内存池重置">8. 内存池重置</h1>
<p>内存池重置操作是通过 <code>ngx_reset_pool</code>
函数来完成的，其源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ngx_reset_pool</span><span class="params">(<span class="type">ngx_pool_t</span> *pool)</span> &#123;</span><br><span class="line">    <span class="type">ngx_pool_t</span>        *p;</span><br><span class="line">    <span class="type">ngx_pool_large_t</span>  *l;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (p = pool; p; p = p-&gt;d.next) &#123;</span><br><span class="line">        p-&gt;d.last = (u_char *) p + <span class="keyword">sizeof</span>(<span class="type">ngx_pool_t</span>);</span><br><span class="line">        p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pool-&gt;current = pool;</span><br><span class="line">    pool-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    pool-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数先遍历大块内存池链表，释放大块内存池。然后遍历小块内存池链表，调整
<code>d.last</code> 指针的偏移，并将 <code>failed</code> 字段重置为
0。</p>
<p>注意，释放小块内存池的循环代码中，存在些许问题，由于只有 pool
指针所指的第一个小块内存池具有全局的数据信息，而后面的次级小块内存池则仅仅包含
<code>last</code>、<code>end</code>、<code>next</code>、<code>failed</code>
这四个信息，但是在该循环中，是按照 <code>ngx_pool_t</code> 的长度来调整
<code>last</code>
指针的，这会使得后面的次级小块内存池在重置后浪费掉部分空间。</p>
<h1 id="清理回调函数">9. 清理回调函数</h1>
<p>现在来考虑如下场景，如果需要申请一个大块内存，该大块内存用于存放一个如下的结构体类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>* str;</span><br><span class="line">	... <span class="comment">// 其它成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中的 <code>str</code> 字段则指向了堆上的一块内存区域，如果现在调用
<code>ngx_pfree</code> 对该大块内存池进行释放，观察
<code>ngx_pfree</code> 的相关源代码可知，其并未处理 <code>str</code>
字段所指向的堆内存，这就会造成内存泄漏。同时由于 C
语言并不存在析构函数来进行内存的清理工作，因此 Nginx
设计了一个回调函数，用于进行内存的清理工作。</p>
<p>位于 <code>ngx_pool_s</code> 结构体中的 <code>cleanup</code>
字段便是做的如此工作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> &#123;</span></span><br><span class="line">    <span class="type">ngx_pool_data_t</span>       d;</span><br><span class="line">    <span class="type">size_t</span>                max;</span><br><span class="line">    <span class="type">ngx_pool_t</span>           *current;</span><br><span class="line">    <span class="type">ngx_chain_t</span>          *chain;</span><br><span class="line">    <span class="type">ngx_pool_large_t</span>     *large;</span><br><span class="line">    <span class="type">ngx_pool_cleanup_t</span>   *cleanup;</span><br><span class="line">    <span class="type">ngx_log_t</span>            *<span class="built_in">log</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*ngx_pool_cleanup_pt)</span><span class="params">(<span class="type">void</span> *data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span>  <span class="title">ngx_pool_cleanup_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span> &#123;</span></span><br><span class="line">    ngx_pool_cleanup_pt   handler;</span><br><span class="line">    <span class="type">void</span>                 *data;</span><br><span class="line">    <span class="type">ngx_pool_cleanup_t</span>   *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中的三个字段的作用如下：</p>
<ul>
<li><code>handler</code>: 存放清理数据的回调函数</li>
<li><code>data</code>: 用于存放回调函数的函数参数</li>
<li><code>next</code>:
表示回调函数也是一个链表形式的数据结构，指向下一个回调函数结构</li>
</ul>
<h1 id="绑定回调函数">10. 绑定回调函数</h1>
<p>函数 <code>ngx_pool_cleanup_add</code>
的作用便是用来绑定回调函数，其源代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ngx_pool_cleanup_t</span>* <span class="title function_">ngx_pool_cleanup_add</span><span class="params">(<span class="type">ngx_pool_t</span> *p, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line">    </span><br><span class="line">    c = ngx_palloc(p, <span class="keyword">sizeof</span>(<span class="type">ngx_pool_cleanup_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (size) &#123;</span><br><span class="line">        c-&gt;data = ngx_palloc(p, size);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    c-&gt;handler = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;next = p-&gt;cleanup;</span><br><span class="line">    </span><br><span class="line">    p-&gt;cleanup = c;</span><br><span class="line">    </span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, p-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;add cleanup: %p&quot;</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，<code>ngx_pool_cleanup_t</code>
也是存放于小块内存池中的，函数最终返回一个
<code>ngx_pool_cleanup_t</code> 的结构，用于用户绑定回调函数。</p>
<p>其示意图如下：</p>
<p><img data-src="/images/NginxMemoryPool/ngx_struct_5.png" style="zoom:60%"/></p>
<h1 id="清理内存池">11. 清理内存池</h1>
<p>函数 <code>ngx_destory_pool</code>
的作用是清理内存池，其相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ngx_destroy_pool</span><span class="params">(<span class="type">ngx_pool_t</span> *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_pool_t</span>          *p, *n;</span><br><span class="line">    <span class="type">ngx_pool_large_t</span>    *l;</span><br><span class="line">    <span class="type">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (c = pool-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler) &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;run cleanup: %p&quot;</span>, c);</span><br><span class="line">            c-&gt;handler(c-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_DEBUG)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * we could allocate the pool-&gt;log from this pool</span></span><br><span class="line"><span class="comment">     * so we cannot use this log while free()ing the pool</span></span><br><span class="line"><span class="comment">     */</span>     </span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;free: %p&quot;</span>, l-&gt;alloc);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;free: %p, unused: %uz&quot;</span>, p, p-&gt;d.end - p-&gt;d.last);</span><br><span class="line">                       </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        ngx_free(p);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，它首先遍历清理用户数据的回调函数链表，调用相应的回调函数来清理内存。然后遍历大块内存池链表以释放大块内存，最后遍历小块内存池链表清理小块内存。</p>
<h1 id="总结">12. 总结</h1>
<p>Nginx 申请内存的流程如下：</p>
<p><img data-src="/images/NginxMemoryPool/flowchart.png" style="zoom:40%"/></p>
]]></content>
      <categories>
        <category>源码剖析</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>内存池</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>STL之空间配置器</title>
    <url>/2022/12/15/STL%E4%B9%8B%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p>STL 空间配置器剖析</p>

</blockquote>
<p>空间配置器 <code>allocator</code>
只是基层内存配置/释放行为的一层薄薄的包装，没有任何效率上的强化。一般而言，C++
内存配置操作和释放操作如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123; ... &#125;;</span><br><span class="line">Foo* pf = <span class="keyword">new</span> Foo;	<span class="comment">// 配置内存，然后构造对象</span></span><br><span class="line"><span class="keyword">delete</span> pf;		<span class="comment">// 将对象析构，然后释放内存</span></span><br></pre></td></tr></table></figure>
<p>其中，new 内含两阶段的操作：</p>
<ol type="1">
<li>调用 ::operator new 配置内存；</li>
<li>调用 Foo::Foo() 构造对象内容。</li>
</ol>
<p>delete 也内含两阶段的操作：</p>
<ol type="1">
<li>调用 Foo::~Foo() 将对象析构；</li>
<li>调用 ::operator delete 释放内存。</li>
</ol>
<p>allocator 将这两阶段的操作分开来。内存配置操作由
<code>alloc::allocate()</code> 负责，内存释放操作由
<code>alloc::deallocate()</code> 负责；对象构造操作由
<code>::construct()</code> 负责，对象析构由 <code>::destroy()</code>
负责。</p>
<p><img data-src="/images/STL_allocator/memory_header.png" style="zoom:70%"/></p>
<p>在 &lt;stl_construct.h&gt; 中，destroy()
有两个版本。第一个版本接受一个指针，将指针所指之物析构掉。而第二个版本接受两个迭代器，将
[first, last)
范围内的所有对象析构掉。但是如果每个对象的析构函数都无关痛痒，而且对象数目很多，则会造成效率上的问题。所以首先利用
<code>value_type()</code> 获得迭代器所指对象的型别，再利用
<code>__type_traits&lt;T&gt;</code>
判断该型别的析构函数是否无关痛痒。</p>
<p>在 &lt;stl_alloc.h&gt;
中，考虑到小型区块所可能造成的内存碎片问题，SGI 设计了双层级配置器：</p>
<ol type="1">
<li>第一级配置器直接使用 malloc() 和 free()</li>
<li>第二级配置器则视情况采用不同的策略。</li>
</ol>
<p>当配置区块超过 128 bytes 时，便调用第一级配置器；当配置区块小于 128
bytes 时，便采用复杂的内存池(memory pool)整理方式。</p>
<p>无论是第一级或第二级配置器，SGI
还为它再包装一个接口如下，使得配置器的接口符合 STL 规格：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>. <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">simple_alloc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> T* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == n ? <span class="number">0</span> : (T*)Alloc::<span class="built_in">allocate</span>(n * <span class="built_in">sizeof</span>(T)); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> T* <span class="title">allocate</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> (T*)Alloc::<span class="built_in">allocate</span>(<span class="built_in">sizeof</span>(T)); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T* p, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">if</span>(<span class="number">0</span> != n) Alloc::<span class="built_in">deallocate</span>(p, n * <span class="built_in">sizeof</span>(T)); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123; Alloc::<span class="built_in">deallocate</span>(p, <span class="built_in">sizeof</span>(T)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/STL_allocator/allocator.png" style="zoom:70%"/></p>
<p>第一级配置器以 malloc()、free()、realloc() 等 C
函数执行实际的内存配置、释放、重配置操作，并实现出类似 C++
<code>new-handler</code> 的机制。SGI 以 malloc() 而非
<code>::operator new</code> 来配置内存，因此，SGI 不能直接使用 C++ 的
<code>set_new_handler()</code> 的操作，必须仿真一个
<code>set_malloc_handler()</code>。一旦内存不足，无法分配，则抛出
<code>bad_alloc</code> 异常，或是利用 exit(1)
直接终止程序，在此之前，会先调用由客户指定的处理例程。</p>
<p>对于第二级配置器，避免了太多小额区块造成内存的碎片，如下图:</p>
<p><img data-src="/images/STL_allocator/cookie.png" style="zoom:70%"/></p>
<p>SGI 第二级配置器的做法是：如果区块过大，超过 128 Bytes
时，就移交给第一级配置器处理。当区块小于 128 Bytes
时，则以内存池管理，也称为【次级配置】。每次配置一大块内存，并维护对应的自由链表，下次若有相同大小的内存需求，则直接从自由链表中取出。同时，如果客户释放小额区块，则由配置器回收到自由链表中。为了方便管理，SGI
第二级配置器会主动将任何小额区块的内存需求量上调至 8
的倍数（例如客户需求 30 Bytes，则上调到 32 Bytes），并维护 16
个链表，各自管理大小分别为
8、16、24、32、40、48、56、64、72、80、88、96、104、112、120、128 bytes
的小额区块。自由链表节点结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">obj</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">obj</span>* free_list_link;</span><br><span class="line">    <span class="type">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/STL_allocator/freelist.png" style="zoom:70%"/></p>
<p>而结点正是因为 union 的缘故，所以从第一个字段出发，obj
被视为指向另一个结点的指针，从第二个字段出发，obj
被视为指向实际区块的指针。这样的方式节省了内存，省下了额外负担。</p>
<p><img data-src="/images/STL_allocator/freelist2.png" style="zoom:50%"/></p>
<p>第二级配置器通过 allocate() 分配内存，通过 deallocate()
释放内存。如果申请内存时，自由链表中没有可用区块时，就调用 refill()
为自由链表重新填充空间。新的空间取自内存池，由
<code>chunk_alloc()</code> 来完成，它通过
<code>end_free - start_free</code> 来判断内存池的水量。</p>
<p>如果水量充足，就直接调出 20 个区块返回给自由链表。</p>
<p><img data-src="/images/STL_allocator/memory_pool.png" style="zoom:50%"/></p>
<p>如果水量不足以提供 20
个区块，但是还足够提供一个以上的区块，就取出这个不足 20
个区块的空间出去，同时，将 pass-by-reference 的 nobjs
参数修改为实际能够供应的区块数。</p>
<p><img data-src="/images/STL_allocator/memory_pool2.png" style="zoom:50%"/></p>
<p>如果内存池连一个区块空间都无法供应，此时便需要利用 malloc() 从 heap
中配置内存，为内存池注入新的内存以供需求。先将内存池剩余的零头配置给合适的自由链表，然后向堆空间申请新的内存，新注入的水量为需求量的
2
倍，再加上一个随着配置次数增加而愈来愈大的附加量。最后将将第一块返回给用户，剩下的
19 块依附在自由链表上，余下的 20+n 个留在内存池中。</p>
<p><img data-src="/images/STL_allocator/memory_pool3.png" style="zoom:50%"/></p>
<p>如果整个堆空间的内存已经不够申请了，malloc() 行动失败，那么
chunk_alloc()
就找寻有无尚未使用之区块，且区块足够大的自由链表，如果找到了就取出来；如果没找到就调用第一级空间配置器，利用其
<code>out-of-memory</code>
处理机制，或许有机会释放其他内存拿来使用。如果可以就成功，否则发出
<code>bad_alloc</code> 异常。</p>
<p><img data-src="/images/STL_allocator/memory_pool4.png" style="zoom:50%"/></p>
]]></content>
      <categories>
        <category>源码剖析</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能分布式网络服务器框架</title>
    <url>/2023/04/21/%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p>使用 C/C++ 开发的一款高性能的后端分布式服务器网络框架。</p>

</blockquote>
<p>该项目具有如下要点：</p>
<ul>
<li>使用 C++11 重写并简化 <a
href="https://github.com/chenshuo/muduo">muduo</a> 网络库；</li>
<li>仿写了 <a href="https://github.com/google/tcmalloc">tcmalloc</a>
的高并发内存池；</li>
<li>加入了 <a href="https://github.com/sylar-yin/sylar">sylar</a>
的日志模块并将其改进为异步日志；</li>
<li>使用到了 <a
href="https://github.com/protocolbuffers/protobuf">protobuf</a> 和 <a
href="https://zookeeper.apache.org/">Zookeeper</a>
来作为分布式协调服务；</li>
</ul>
<div class="text-center" style="text-align:center">
<a class="btn" href="https://github.com/Kohirus/Apollo" title="GitHub"><i class="fab fa-github fa-fw fa-lg"></i>Github-Apollo</a>
</div>
<h1 id="项目部署">项目部署</h1>
<h2 id="开发环境">1. 开发环境</h2>
<ul>
<li>OS：Ubuntu 22.04 LTS</li>
<li>构建工具：CMake 3.16.3</li>
<li>编译器：GCC 9.4.0</li>
<li>调试器：GDB 9.2</li>
<li>第三方模块：
<ul>
<li><a href="https://github.com/nlohmann/json">json.cpp</a>：3.11.2</li>
<li>protobuf：3.17.0</li>
<li>ZooKeeper：3.4.10</li>
</ul></li>
</ul>
<h2 id="部署方法">2. 部署方法</h2>
<p>可以运行 <code>autobuild.sh</code> 直接进行编译。或者创建
<code>build</code> 目录并进入，然后输入如下命令进行编译：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>如果不需要采用 tcmallloc 内存池模块，而是采用系统原生的
malloc/free，那么更改项目根路径下的 CMakeLists.txt
文件中的如下内容即可：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># option(TCMALLOC &quot;use tcmalloc&quot; ON) </span></span><br><span class="line"><span class="keyword">option</span>(TCMALLOC <span class="string">&quot;use tcmalloc&quot;</span> <span class="keyword">OFF</span>)</span><br></pre></td></tr></table></figure>
<p>或者进入 build 目录使用如下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cmake .. -DTCMALLOC=ON</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>如果需要采用 poll 而非 epoll 来作为 I/O 复用模型，那么修改根路径下的
CMakeLists.txt 文件中的如下内容即可：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># option(APLUSEPOLL &quot;use poll&quot; OFF)</span></span><br><span class="line"><span class="keyword">option</span>(APLUSEPOLL <span class="string">&quot;use poll&quot;</span> <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure>
<p>或者进入 build 目录使用如下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cmake .. -DAPLUSEPOLL=ON</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<div class="note info"><p>默认情况下，运行 autobuild.sh 文件时会启用 tcmalloc 内存池，同时使用
epoll 来作为 I/O 复用模型。</p>
</div>
<div class="note danger"><p>注意，使用该框架时需要在可执行文件的所在路径下添加
<code>config.json</code>
配置文件，以配置日志、节点服务器、发现服务器等信息。</p>
</div>
<h2 id="配置文件">3. 配置文件</h2>
<p>配置文件位于可执行文件的所在路径下，且名为
<code>config.json</code>，如下是其示例配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;log&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;root&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="string">&quot;INFO&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;formatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%d&#123;%Y-%m-%d %H:%M:%S&#125;%T%t%T%c%T[%p]%T%f:%l%T%m%n&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;appenders&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;file&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./log/root.txt&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;async&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stdout&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rpc&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DEBUG&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;formatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%d&#123;%Y-%m-%d %H:%M:%S&#125;%T%t%T%c%T[%p]%T%f:%l%T%m%n&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;appenders&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;file&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./log/rpc.txt&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;async&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;rpc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">8000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;thread&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;zookeeper&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">5000</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中，配置信息主要由如下三部分组成：</p>
<ul>
<li>log：日志配置信息
<ul>
<li>name：日志名称</li>
<li>level：日志等级，支持DEBUG、INFO、WARN、ERROR、FATAL</li>
<li>formatter：日志格式</li>
<li>appenders：日志输出目的地，可以配置多个
<ul>
<li>type：日志类型，支持file(文件)、stdout(标准输出)</li>
<li>file：文件名称</li>
<li>async：是否为异步日志(目前尚未支持)</li>
</ul></li>
</ul></li>
<li>rpc：RPC节点配置信息
<ul>
<li>ip：IP地址</li>
<li>port：端口号</li>
<li>thread：线程数目</li>
</ul></li>
<li>zookeeper：发现服务器的配置信息
<ul>
<li>ip：IP地址</li>
<li>port：端口号</li>
</ul></li>
</ul>
<p>对于日志格式而言，所支持的字段如下：</p>
<table>
<thead>
<tr class="header">
<th>格式化字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>%m</td>
<td>消息内容</td>
</tr>
<tr class="even">
<td>%p</td>
<td>日志等级</td>
</tr>
<tr class="odd">
<td>%c</td>
<td>日志名称</td>
</tr>
<tr class="even">
<td>%t</td>
<td>线程ID</td>
</tr>
<tr class="odd">
<td>%n</td>
<td>换行符</td>
</tr>
<tr class="even">
<td>%d</td>
<td>日志时间</td>
</tr>
<tr class="odd">
<td>%f</td>
<td>文件名</td>
</tr>
<tr class="even">
<td>%l</td>
<td>行号</td>
</tr>
<tr class="odd">
<td>%T</td>
<td>制表符</td>
</tr>
<tr class="even">
<td>%N</td>
<td>线程名称</td>
</tr>
</tbody>
</table>
<div class="note info"><p>时间的格式化字符见 <code>strftime</code> 函数。</p>
</div>
<h2 id="如何使用">4. 如何使用</h2>
<p>首先需要通信双方约定消息格式，示例文件如下，其中
<code>option cc_generic_services = true</code> 必须开启：</p>
<figure class="highlight proto"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span> &#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> errmsg = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span> &#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span> &#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserServiceRpc</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Login(LoginRequest) <span class="keyword">returns</span>(LoginResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过如下命令在当前路径下生成相应的头文件和源文件，该头文件中会包含两个类：<code>UserServiceRpc</code>
和 <code>UserServiceRpc_Stub</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">proto xxx.proto --cpp_out=./</span><br></pre></td></tr></table></figure>
<p>对于服务提供方而言，需要继承 <code>UserServiceRpc</code>
类，并重写相应的方法，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> : <span class="keyword">public</span> UserServiceRpc &#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Login</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; pwd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现业务方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重新基类方法</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Login</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> ::fixbug::LoginRequest*             request,</span></span></span><br><span class="line"><span class="params"><span class="function">    ::fixbug::LoginResponse*                  response,</span></span></span><br><span class="line"><span class="params"><span class="function">    ::google::protobuf::Closure*              done)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过request参数获取请求方的函数参数</span></span><br><span class="line">    std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">    std::string pwd  = request-&gt;<span class="built_in">pwd</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行本地业务</span></span><br><span class="line">    <span class="type">bool</span> res = <span class="built_in">Login</span>(name, pwd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将响应结果写入response参数</span></span><br><span class="line">    fixbug::ResultCode* code = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">    code-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">    code-&gt;<span class="built_in">set_errmsg</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    response-&gt;<span class="built_in">set_success</span>(res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行回调操作</span></span><br><span class="line">    done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 把UserService对象发布到RPC节点上</span></span><br><span class="line">  RpcProvider provider;</span><br><span class="line">  provider.<span class="built_in">notifyService</span>(<span class="keyword">new</span> <span class="built_in">UserService</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动一个rpc服务发布节点</span></span><br><span class="line">  provider.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于服务请求方而言，实例化一个 <code>UserServiceRpc_Stub</code>
对象，然后将函数参数放入到 request 对象中，然后通过
<code>UserService_Stub</code> 对象执行远程调用即可，最终通过
RpcControllerImpl 得知远程调用是否成功，如果成功则通过 response
对象取出服务请求的结果即可，示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">fixbug::UserServiceRpc_Stub <span class="title">stub</span><span class="params">(<span class="keyword">new</span> apollo::RpcChannelImpl)</span></span>;</span><br><span class="line">  fixbug::LoginRequest        request;</span><br><span class="line">  request.<span class="built_in">set_name</span>(<span class="string">&quot;zhang san&quot;</span>);</span><br><span class="line">  request.<span class="built_in">set_pwd</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">  fixbug::LoginResponse response;</span><br><span class="line">  <span class="comment">// 发起RPC同步调用</span></span><br><span class="line">  apollo::RpcControllerImpl controller;</span><br><span class="line">  stub.<span class="built_in">Login</span>(&amp;controller, &amp;request, &amp;response, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (controller.<span class="built_in">Failed</span>()) &#123;</span><br><span class="line">      std::cout &lt;&lt; controller.<span class="built_in">ErrorText</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// RPC调用完成 读取结果</span></span><br><span class="line">      <span class="keyword">if</span> (response.<span class="built_in">result</span>().<span class="built_in">errcode</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">          std::cout &lt;&lt; <span class="string">&quot;rpc login response: &quot;</span> &lt;&lt; response.<span class="built_in">success</span>() &lt;&lt; std::endl;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          std::cout &lt;&lt; <span class="string">&quot;failed to rpc login: &quot;</span> &lt;&lt; response.<span class="built_in">result</span>().<span class="built_in">errmsg</span>() &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="内存池模块">内存池模块</h1>
<p>该项目所使用的内存池原型是 Google 的开源项目 tcmalloc，其全称为
Thread-Caching Malloc，即线程缓存的
malloc，实现了高效的多线程内存管理，用于替换系统的内存分配相关函数，即
malloc 和 free。</p>
<p>内存池主要解决的就是效率问题，它能够避免让程序频繁的向系统申请和释放内存。其次，内存池作为系统的内存分配器，还需要尝试解决内存碎片的问题，内存碎片分为如下两种：</p>
<ul>
<li><strong>外部碎片</strong>：指的是空闲的小块内存区域，由于这些内存空间不连续，以至于合计的内存足够，但是不能满足一些内存分配的需求。</li>
<li><strong>内部碎片</strong>：指的是由于一些对齐的需求，导致分配出去的空间中一些内存无法被充分利用。</li>
</ul>
<div class="note info"><p>内存池尝试解决的是外部碎片的问题，同时也尽可能的减少内部碎片的产生。</p>
</div>
<p>该内存池的整体架构如下图所示：</p>
<p><img data-src="/images/apollo/memory_pool_structure.png" width="50%" height="50%"/></p>
<p>其主要由以下三个部分组成：</p>
<ul>
<li><code>Thread Cache</code>: 线程缓存是每个线程独有的，用于小于等于
256KB 的内存分配，每个线程独享一个 ThreaCache了。</li>
<li><code>Central Cache</code>: 中心缓存是所有线程共享的，当 ThreadCache
需要内存时会按需从 CentralCache 中获取内存，而当 ThreadCache
中的内存满足一定条件时，CentralCache 也会在合适的时机对其进行回收。</li>
<li><code>Page Cache</code>:
页缓存中存储的内存是以页为单位进行存储及分配的，当 CentralCache
需要内存时，PageCache 会分配出一定数量的页给 CentralCache，而当
CentralCache 中的内存满足一定条件时，PageCache
也会在合适的时机对其进行回收，并将回收的内存尽可能的进行合并，组成更大的连续内存块，缓解内存碎片的问题。</li>
</ul>
<p>上述三个部分的主要作用如下：</p>
<ul>
<li>Thread Cache: 主要解决锁竞争的问题；</li>
<li>Central Cache: 主要负责居中调度的问题；</li>
<li>Page Cache: 主要负责提供以页为单位的大块内存；</li>
</ul>
<h2 id="threadcache">1.ThreadCache</h2>
<p>Thread Cache 的结构如下图所示：</p>
<p><img data-src="/images/apollo/thread_cache.png" width="55%" height="55%"/></p>
<p>通过使用<strong>字节对齐</strong>的方法来减少哈希桶的数目，并且进一步增加内存利用率，在设计时，让不同的范围的字节数按照不同的对齐数进行对齐，具体的对齐方式如下：</p>
<table>
<thead>
<tr class="header">
<th>字节数</th>
<th>对齐数</th>
<th>哈希桶下标</th>
<th>自由链表数目</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[1, 128]</td>
<td>8</td>
<td>[0, 16)</td>
<td>16</td>
</tr>
<tr class="even">
<td>[129, 1024]</td>
<td>16</td>
<td>[16, 72)</td>
<td>56</td>
</tr>
<tr class="odd">
<td>[1025, 8*1024]</td>
<td>128</td>
<td>[72, 128)</td>
<td>56</td>
</tr>
<tr class="even">
<td>[8*1024+1, 64*1024]</td>
<td>1024</td>
<td>[128, 184)</td>
<td>56</td>
</tr>
<tr class="odd">
<td>[64*1024+1, 256*1024]</td>
<td>8*1024</td>
<td>[184, 208)</td>
<td>24</td>
</tr>
</tbody>
</table>
<p>为了实现每个线程无锁访问属于自己的 Thread
Cache，就需要用到<strong>线程局部存储</strong>(Thread Local Storage,
TLS)，使用该存储方法的变量在它所在的线程是全局可访问的，但是不能被其它线程访问到，这样就保证了数据的线程独立性。</p>
<p>当某个线程申请的对象不用了，可以将其释放给 Thread Cache，然后 Thread
Cache 将该对象插入到哈希桶的自由链表当中即可。</p>
<p>但是随着线程不断地释放，对应自由链表中的长度也会越来越长，这些内存堆积在一个
Thread Cache 中就是一种浪费，此时应该将这些内存还给 Central
Cache，这样一来，这些内存对于其它线程来说就是可申请的，因此当 Thread
Cache 中某个桶当中的自由链表太长时，可以将其释放给 Central Cache。</p>
<h2 id="centralcache">2. CentralCache</h2>
<p>当线程申请某一大小的内存时，如果 Thread Cache
中对应的自由链表不为空，那么直接取出一个内存块返回即可，但如果此时该自由链表为空，那么这时
Thread Cache 就需要向 Central Cache 申请内存了。</p>
<p>Central Cache 的结构与 Thread Cache
是一样的，都是哈希桶结构，并且所遵循的对齐规则也一致。这样做的好处是当
Thread Cache 的某个桶中没有内存时，就可以直接到 Central Cache
中相对应的哈希桶中取内存。</p>
<p>Central Cache 与 Thread Cache 不同之处有两点：</p>
<ol type="1">
<li>Central Cache 是所有线程共享的，而 Thread Cache 是线程独享的；</li>
<li>Central Cache 的哈希桶中挂载的是 Span，而 Thread Cache
的哈希桶中挂载的是切好的内存块；</li>
</ol>
<p>其结构如下所示：</p>
<p><img data-src="/images/apollo/central_cache.png" width="65%" height="65%"/></p>
<p>由于 Central Cache 是所有线程共享的，多个 Thread Cache
可能在同一时刻向 Central Cache
申请内存块，因此为了保证线程安全，需要加锁控制。此外，由于只有多个线程同时访问
Central Cache
的同一个桶时才会存在锁竞争，因此无需用锁来锁住所有哈希桶，只需锁住当前所访问的哈希桶即可。</p>
<p>当 Thread Cache 向 Central Cache 申请内存时，如果给的太少，那么
Thread Cache 在短时间用完了又会再来申请；但是如果给的太多，那么 Thread
Cache
可能用不完而浪费大量的空间。为此，此处采用<strong>慢反馈调节算法</strong>，当
Thread Cache 向 Central Cache
申请内存时，如果申请的是较小的对象，那么可以多给一点，但如果申请的是较大的对象，就可以少给一点。</p>
<p>当 Thread Cache 中的某个自由链表太长时，会将自由链表中的对象归还给
Central Cache 中的 Span。但是需要注意的是，归还给 Central Cache
的这些对象不一定都属于同一个 Span 的，且 Central Cache
中的每个哈希桶中都可能不止一个
Span，因此归还时不仅需要知道该对象属于哪一个桶，还需要知道它属于这个桶中的哪一个
Span。为了建立页号和 Span
之间的映射，需要使用一种哈希表结构进行管理，一种方式是采用 C++ 中的
unordered_map，另一种方式是采用<strong>基数树</strong>数据结构。</p>
<h2 id="pagecache">3. PageCache</h2>
<p>Page Cache 的结构与 Central Cache 一样，都是哈希桶的结构，并且 Page
Cache 的每个哈希桶中都挂的是一个个的 Span，这些 Span
也是按照双向链表的结构连接起来的。</p>
<p>但是，Page Cache 的映射规则与 Central Cache 和 Thread Cache
不同，其采用的是<strong>直接定址法</strong>，比如 1 号桶挂的都是 1 页的
Span，2 号桶挂的都是 2 页的 Span，以此类推。</p>
<p>其次，Central Cache 每个桶中的 Span
都被切为了一个个对应大小的对象，以供 Thread Cache 申请。而 Page Cache
服务的是 Central Cache，当 Central Cache 中没有 Span 时，向 Page Cache
申请的是某一固定页数的 Span。而如果切分这个申请到的 Span 就应该由
Central Cache 自己来决定。</p>
<p>其结构如下图所示：</p>
<p><img data-src="/images/apollo/page_cache.png" width="65%" height="65%"/></p>
<p>当每个线程的 Thread Cache 没有内存时都会向 Central Cache
申请，此时多个线程的 Thread Cache 如果访问的不是 Central Cache
的同一个桶，那么这些线程是可以同时进行访问的。这时 Central Cache
的多个桶就可能同时向 Page Cache 申请内存，所以 Page Cache
也是存在线程安全问题的，因此在访问 Page Cache 时也必须要加锁。</p>
<p>但是此处的 Page Cache 不能使用桶锁，因为当 Central Cache 向 Page
Cache 申请内存时，Page Cache 可能会将其他桶中大页的 Span 切小后再给
Central Cache。此外，当 Central Cache 将某个 Span 归还给 Page Cache
时，Page Cache 也会尝试将该 Span 与其它桶当中的 Span 进行合并。</p>
<p>也就是说，在访问 Page Cache
时，可能同时需要访问多个哈希桶，如果使用桶锁则可能造成大量频繁的加锁和解锁，导致程序的效率底下。因此在访问
Page Cache 时没有使用桶锁，而是用一个大锁将整个 Page Cache 锁住。</p>
<p>如果 Central Cache 中有某个 Span 的 <code>useCnt_</code> 减到 0
了，那么 Central Cache 就需要将这个 Span 归还给 Page Cache
了。为了缓解内存碎片问题，Page Cache 还需要尝试将还回来的 Span
与其它空闲的 Span 进行合并。</p>
<h2 id="基数树">4. 基数树</h2>
<p>由于在 PageCache 中最初建立页号与 Span 之间的映射关系时，采用的是
unordered_map 数据结构，但是通过性能测试发现，内存池的性能并未优于原生的
malloc/free 接口，因此通过 Visual Studio 的性能分析工具发现性能瓶颈位于
unordered_map 处。</p>
<p>这主要是因为 unordered_map
不是线程安全的，在多线程环境下需要加锁，而大量的加锁则会导致资源的消耗和性能的下降，因此在映射页号与
Span 之间的关系时，采用基数树（Radix Tree）数据结构来进行优化。</p>
<p>当采用如下图所示的单层基数树时，在 32 位平台下，以一页大小为 8K(<span
class="math inline">\(2^{13}\)</span>) 为例，此时页的数目就是 <span
class="math inline">\(2^{32}\div
2^{13}=2^{19}\)</span>，因此存储页号最多需要 19 个比特位，同时由于 32
位平台下的指针大小为 4 字节，因此该数组的大小就是 <span
class="math inline">\(2^{19}\times
4=2^{21}=2M\)</span>，内存消耗不大，是可行的。但是如果是在 64
位平台下，此时该数组的大小就是 <span class="math inline">\(2^{51}\times
8=2^{54}=2^{24}G\)</span>，这显然是不可行的：</p>
<p><img data-src="/images/apollo/radix_tree_1.png" width="40%" height="40%"/></p>
<p>如下图所示，为二层基数树，同样在 32 位平台下，以一页的大小为 8K
为例来说明，此时存储页号最多需要 19 个比特位。而二层基数树实际上就是把这
19 个比特位分为两次进行映射。例如，前 5
个比特位在基数树的第一层进行映射，映射后得到对应的第二层，然后用剩下的比特位在基数树的第二层进行映射，映射后最终得到该页号所对应的
Span 指针。</p>
<p><img data-src="/images/apollo/radix_tree_2.png"/></p>
<p>在二层基数树中，第一层的数组占用 <span
class="math inline">\(2^5\times 4=2^7\)</span> Bytes
空间，第二层的数组最多占用 <span class="math inline">\(2^5\times
2^{14}\times
4=2^{21}=2M\)</span>。二层基数树相比与一层基数树的好处就是，一层基数树必须一开始就把
2M
的数组开辟出来，而二层基数树一开始只需要将第一层的数组开辟出来，当需要进行某一页号映射时再开辟对应的第二层的数组就行了。</p>
<p>在 32 位平台下，一层基数树和二层基数树都是适用的，但是在 64
位平台下，就需要使用下图所示的三层基数树了。三层基数树类似于二层基数树，实际上就是把存储页号的若干比特分为三次进行映射，而且只有当需要建立某一页号的映射关系时，才会开辟对应的数组空间，在一定程度上节约了内存空间：</p>
<p><img data-src="/images/apollo/radix_tree_3.png"/></p>
<h2 id="性能测试">5. 性能测试</h2>
<p>单线程下内存池性能测试结果如下表所示，其中 <code>alloc/dealloc</code>
表示使用内存池来进行内存的申请和分配，而 <code>malloc/free</code>
表示使用系统原生的 API 来进行内存的申请和分配，表格中的单位为秒：</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 17%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th>申请次数</th>
<th>malloc</th>
<th>free</th>
<th>malloc&amp;free</th>
<th>alloc</th>
<th>dealloc</th>
<th>alloc&amp;dealloc</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>100</td>
<td>0.000108</td>
<td>2.2e-05</td>
<td>0.00013</td>
<td>0.000366</td>
<td>6e-05</td>
<td>0.000426</td>
</tr>
<tr class="even">
<td>500</td>
<td>0.000344</td>
<td>0.000111</td>
<td>0.000455</td>
<td>0.002713</td>
<td>0.000235</td>
<td>0.002948</td>
</tr>
<tr class="odd">
<td>1000</td>
<td>0.000935</td>
<td>0.000409</td>
<td>0.001344</td>
<td>0.007691</td>
<td>0.000355</td>
<td>0.008046</td>
</tr>
<tr class="even">
<td>5000</td>
<td>0.021884</td>
<td>0.004798</td>
<td>0.026682</td>
<td>0.007954</td>
<td>0.00218</td>
<td>0.010134</td>
</tr>
<tr class="odd">
<td>10000</td>
<td>0.06108</td>
<td>0.011623</td>
<td>0.071731</td>
<td>0.020134</td>
<td>0.003578</td>
<td>0.023712</td>
</tr>
<tr class="even">
<td>20000</td>
<td>0.120307</td>
<td>0.028152</td>
<td>0.148459</td>
<td>0.024508</td>
<td>0.006907</td>
<td>0.031415</td>
</tr>
<tr class="odd">
<td>30000</td>
<td>0.199733</td>
<td>0.043747</td>
<td>0.24348</td>
<td>0.03611</td>
<td>0.011694</td>
<td>0.047804</td>
</tr>
</tbody>
</table>
<p>单线程性能测试结果的折线图如下所示：</p>
<p><img data-src="/images/apollo/performance_test_st.png"/></p>
<p>多线程下的性能测试结果如下表所示，每个线程都需申请/释放内存 10000
次：</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 17%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th>线程数目</th>
<th>malloc</th>
<th>free</th>
<th>malloc&amp;free</th>
<th>alloc</th>
<th>dealloc</th>
<th>alloc&amp;dealloc</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0.06108</td>
<td>0.011623</td>
<td>0.071731</td>
<td>0.06108</td>
<td>0.011623</td>
<td>0.071731</td>
</tr>
<tr class="even">
<td>2</td>
<td>0.2204</td>
<td>0.076146</td>
<td>0.296546</td>
<td>0.059878</td>
<td>0.015874</td>
<td>0.075752</td>
</tr>
<tr class="odd">
<td>3</td>
<td>0.613199</td>
<td>0.194174</td>
<td>0.807373</td>
<td>0.156596</td>
<td>0.03168</td>
<td>0.188276</td>
</tr>
<tr class="even">
<td>4</td>
<td>0.492761</td>
<td>0.060352</td>
<td>0.553113</td>
<td>0.492761</td>
<td>0.060352</td>
<td>0.553113</td>
</tr>
<tr class="odd">
<td>5</td>
<td>2.65943</td>
<td>0.416495</td>
<td>3.07592</td>
<td>0.680774</td>
<td>0.092576</td>
<td>0.77335</td>
</tr>
<tr class="even">
<td>6</td>
<td>4.16152</td>
<td>0.528937</td>
<td>4.69046</td>
<td>0.815121</td>
<td>0.123539</td>
<td>0.93866</td>
</tr>
<tr class="odd">
<td>7</td>
<td>5.43473</td>
<td>0.805814</td>
<td>6.24054</td>
<td>1.18223</td>
<td>0.166473</td>
<td>1.34871</td>
</tr>
</tbody>
</table>
<p>多线程性能测试结果的折线图如下所示：</p>
<p><img data-src="/images/apollo/performance_test_mt.png"/></p>
<p>综合对比上面的测试数据，可以看出，当申请的内存次数较小时，使用系统原生的
API 更为合适，而如果申请次数过多时，内存池的优势就逐渐体现出来了。</p>
<h1 id="网络通信模块">网络通信模块</h1>
<p>网络通信模块采用的是 muduo 网络库，本项目通过使用 C++11 简化 muduo
网络库，同时去除了 Boost 库的依赖以及一些冗余的组件，提取出 muduo
库中的核心思想，即 One Loop Per Thread。</p>
<h2 id="reactor">1. Reactor</h2>
<p>该网络库采用的是 Reactor
事件处理模式。在《Linux高性能服务器编程》中，对于 Reactor
模型的描述如下：<strong>主线程（即 I/O
处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程（即逻辑单元）。此外，主线程不做任何其他实质性的工作。读写数据、接受新的连接，以及处理客户请求均在工作线程中完成</strong>。Reactor
模式的时序图如下：</p>
<p><img data-src="/images/apollo/reactor_model.png" width="80%" height="80%"/></p>
<p>而 muduo 网络库的时序图则如下图所示：</p>
<p><img data-src="/images/apollo/muduo_timing_diagram.png" width="85%" height="85%"></p>
<p>其次，在《Linux高性能服务器编程》一书中还提到了<strong>半同步/半异步</strong>的并发模式，注意，此处的“异步”与
I/O 模型中的异步并不相同，I/O
模型中的“同步”和“异步”的区分是内核应用程序通知的是何种事件（就绪事件还是完成事件），以及由谁来完成
I/O
读写（是应用程序还是内核）。而在并发模式中，“同步”指的是完全按照代码序列的顺序执行，“异步”则指的是程序的执行需要由系统事件来驱动，比如常见的系统终端、信号等。</p>
<p>而 muduo
库所采用的便是高效的半同步/半异步模式，其结构如下图所示：</p>
<p><img data-src="/images/apollo/structure.png" width="75%" height="75%"/></p>
<p>上图中，主线程只管理监听 socket，连接 socket
由工作线程来管理。当有新的连接到来时，主线程就接受并将新返回的连接
socket 派发给某个工作线程，此后在该 socket 上的任何 I/O
操作都由被选中的工作线程来处理，直到客户关闭连接。主线程向工作线程派发
socket
的最简单的方式，是往它和工作线程之间的管道写数据。工作线程检测到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。如果是，则把新
socket 上的读写事件注册到自己的 epoll
内核事件表中。上图中的每个线程都维持自己的事件循环，它们各自独立的监听不同的事件。因此，在这种高效的半同步/半异步模式中，每个线程都工作在异步模式，所以它并非严格意义上的半同步/半异步模式。</p>
<p>通常情况下，Reactor 模式的实现有如三几种方式：</p>
<ul>
<li>Single Reactor - Single Thread</li>
<li>Single Reactor - Multi Threads</li>
<li>Multi Reactors - Multi Threads</li>
</ul>
<p>对于 “Single Reactor - Single Thread” 模型而言，其通常只有一个 epoll
对象，所有的接收客户端连接、客户端读取、客户端写入操作都包含在一个线程内，如下图所示：</p>
<p><img data-src="/images/apollo/sr_st_model.png" width="65%" height="65%"/></p>
<p>但在目前的单线程 Reactor 模式中，不仅 I/O 操作在该 Reactor
线程上，连非 I/O 的业务操作也在该线程上进行处理了，这可能会大大延迟 I/O
请求的响应。为了提高服务器的性能，我们需要将非 I/O 的业务逻辑操作从
Reactor 线程中移动到工作线程中进行处理。</p>
<p>为此，可以通过使用线程池模型的方法来改进，即 “Single Reactor - Multi
Threads”
模型，其结构如下图所示。将读写的业务逻辑交给具体的线程池来实现，这样可以显示
reactor 线程对 IO 的响应，以此提升系统性能。</p>
<p><img data-src="/images/apollo/sr_mt_model.png" width="65%" height="65%"/></p>
<p>尽管现在已经将所有的非 I/O 操作交给了线程池来处理，但是所有的 I/O
操作依然由 Reactor
单线程执行，在高负载、高并发或大数据量的应用场景，依然较容易成为瓶颈。</p>
<p>为了继续提升服务器的性能，进而改造出了如下图所示的 “Multi Reactors -
Multi Threads” 模型：</p>
<p><img data-src="/images/apollo/mr_mt_model.png" width="75%" height="75%"/></p>
<p>在这种模型中，主要分为两个部分：mainReactor、subReactors。
mainReactor
主要负责接收客户端的连接，然后将建立的客户端连接通过负载均衡的方式分发给
subReactors，subReactors 则负责具体的每个连接的读写，而对于非 IO
的操作，依然交给工作线程池去做，对逻辑进行解耦。</p>
<p>而在 muduo 网络库中，便采用的是此种模型，每一个 Reactor 都是一个
EventLoop 对象，而每一个 EventLoop 则和一个线程唯一绑定，这也就是 One
Loop Per Thread 的含义所在。其中，MainLoop
只负责新连接的建立，连接建立成功后则将其打包为 TcpConnection 对象分发给
SubLoop，在 muduo 网络库中，采用的是 “轮询算法” 来选择处理客户端连接的
SubLoop。之后，这个已建立连接的任何操作都交付给该 SubLoop 来处理。</p>
<p>通常在服务器模型中，我们可以使用 “任务队列” 的方式向 SubLoop
派发任务，即 MainLoop 将需要执行的任务放到任务队列中，而 SubLoop
则从任务队列中取出任务并执行，当任务队列中没有任务时，SubLoop
则进行休眠直到任务队列中有任务出现。但是在 muduo
网络库却中并未采用这一方式，而是采用了另一个更加高效的方式，以便让
MainLoop 唤醒 SubLoop 处理任务。</p>
<p>在上述的 “半同步/半异步” 模式中，我们提到了，主线程向工作线程派发
socket
最简单的方式，就是往它和工作线程之间的管道写数据。为此，我们可以在
MainLoop 和 SubLoop 之间建立管道来进行通信，当有任务需要执行时，MainLoop
通过管道将数据发送给 SubLoop，SubLoop 则通过 epoll
模型监听到了管道上所发生的可读（EPOLLIN）事件，然后调用相应的读事件回调函数来处理任务。</p>
<p>但是在 muduo 库中，则采用了更为高效的 <code>eventfd()</code>
接口，它通过创建一个文件描述符用于事件通知，自 Linux 2.6.22
以后开始支持。</p>
<div class="note info"><p>eventfd 在信号通知的场景下，相对比 pipe
有非常大的资源和性能优势，它们的对比如下：</p>
<ol type="1">
<li><p>首先在于它们所打开的文件数量的差异，由于 pipe 是半双工的传统 IPC
实现方式，所以两个线程通信需要两个 pipe 文件描述符，而用 eventfd
则只需要打开一个文件描述符。总所周知，文件描述符是系统中非常宝贵的资源，Linux
的默认值只有 1024 个，其次，pipe
只能在两个进程/线程间使用，面向连接，使用之前就需要创建好两个 pipe ,而
eventfd 是广播式的通知，可以多对多。</p></li>
<li><p>另一方面则是内存使用的差别，eventfd
是一个计数器，内核维护的成本非常低，大概是自旋锁+唤醒队列的大小，8
个字节的传输成本也微乎其微，而 pipe
则完全不同，一来一回的数据在用户空间和内核空间有多达 4
次的复制，而且最糟糕的是，内核要为每个 pipe 分配最少 4K
的虚拟内存页，哪怕传送的数据长度为 0。</p></li>
</ol>
</div>
<h2 id="io-multiplexing">2. I/O multiplexing</h2>
<p>在 Linux 系统下，常见的 I/O 复用机制有三种：select、poll 和
epoll。</p>
<p>其中，select 模型的缺点如下：</p>
<ol type="1">
<li>单个进程能够监视的文件描述符的数量存在最大限制，通常是
1024，当然可以更改数量，但由于 select
采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差；</li>
<li>内核和用户空间的内存拷贝问题，select
需要复制大量的句柄数据结构，会产生巨大的开销；</li>
<li>select
返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件；</li>
<li>select
的触发方式是水平触发，应用程序如果没有对一个已经就绪的文件描述符进行相应的
I/O 操作，那么之后每次 select 调用还是会将这些文件描述符通知进程；</li>
</ol>
<p>相比于 select 模型，poll
则使用链表来保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依然存在。</p>
<p>而 epoll 的实现机制与 select/poll 机制完全不同，它们的缺点在 epoll
模型上不复存在。其高效的原因有以下两点：</p>
<ol type="1">
<li>它通过使用<strong>红黑树</strong>这种数据结构来存储 epoll
所监听的套接字。当添加或者删除一个套接字时（epoll_ctl），都是在红黑树上进行处理，由于红黑树本身插入和删除性能比较好，时间复杂度为
O(logN)，因此其效率要高于 select/poll。</li>
<li>当把事件添加进来的时候时候会完成关键的一步，那就是该事件会与相应的设备（网卡）驱动程序建立回调关系，当相应的事件发生后，就会调用这个回调函数。这个回调函数其实就是把该事件添加到
<code>rdllist</code> 这个双向链表中。那么当我们调用 epoll_wait
时，epoll_wait 只需要检查 rdlist
双向链表中是否有存在注册的事件，效率非常可观。</li>
</ol>
<p>epoll 对文件描述符的操作有两种模式：LT（Level Trigger，电平触发）和
ET（Edge Trigger，边沿触发）模式。其中，LT
模式是默认的工作模式，这种模式下 epoll 相当于一个效率较高的 poll。当往
epoll 内核事件表中注册一个文件描述符上的 EPOLLOUT 事件时，epoll 将以 ET
模式来操作该文件描述符。ET 模式是 epoll 的高效工作模式。</p>
<p>对于采用 LT 工作模式的文件描述符，当 epoll_wait
检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用
epoll_wait 时，epoll_wait
还会再次向应用程序通告此事件，直到该事件被处理。而对于采用 ET
工作模式的文件描述符，当 epoll_wait
检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的
epoll_wait 调用将不再向应用程序通知这一事件。可见，ET
模式在很大程度上降低了同一个 epoll 事件被重复触发的此时，因此效率要比 LT
模式高。</p>
<p>在 muduo 网络库中，则采用了 LT 工作模式，其原因如下：</p>
<ol type="1">
<li>不会丢失数据或者消息，应用没有读取完数据，内核是会不断上报的；</li>
<li>每次读数据只需要一次系统调用；照顾了多个连接的公平性，不会因为某个连接上的数据量过大而影响其他连接处理消息；</li>
</ol>
<p>在 muduo 网络库中，借助于 Linux 下“一切皆文件”的思想，通过 epoll
进行管理的主要有如下三个类型的事件：</p>
<ul>
<li><strong>网络 I/O
事件</strong>：通过套接字（socket）文件描述符进行管理；</li>
<li><strong>线程通知事件</strong>：通过 eventfd 唤醒 SubLoop
处理相应的任务；</li>
<li><strong>定时器事件</strong>：通过 timerfd 来处理定时器事件；</li>
</ul>
<h2 id="qps">3. QPS</h2>
<p>QPS(Query Per Second) 即每秒查询率，QPS
是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p>
<p>未完成...</p>
<h1 id="日志模块">日志模块</h1>
<p>未完成...</p>
<h1 id="rpc模块">RPC模块</h1>
<p>RPC（Remote Procedure Call），即远程过程调用，也就是说两台服务器
A，B，一个应用部署在 A 服务器上，想要调用 B
服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。RPC
的主要功能目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。为实现该目标，RPC
框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用。</p>
<h2 id="分布式">1. 分布式</h2>
<p>考虑一个聊天业务，我们对其进行子模块划分，那么可以大致分为：用户管理、好友管理、群组管理、消息管理、文件管理，其中每一个模块都包含了一个特定的业务。将该服务器部署在一个单机上面，如下图所示：</p>
<p><img data-src="/images/apollo/single_server_model.png" width="40%" height="40%"/></p>
<p>上图中所示的单机服务器模型存在如下缺点：</p>
<ol type="1">
<li>受到硬件资源的限制，聊天服务器所能承受的用户的并发量较低；</li>
<li>修改任意模块的代码，会导致整个项目代码的重新编译、部署。项目如果过大，会很耗时；</li>
<li>在系统中，有些模块是属于 CPU 密集型的，而有些模块则是属于 I/O
密集型的，造成各个模块对于硬件资源的需求各不相同，而单机服务器只能给所有模块提供同一种硬件资源，无法做到硬件资源的特化；</li>
<li>如果服务器出现异常，那么整个服务都会挂掉；</li>
</ol>
<p>为了解决单机服务器所带来的并发量较低的缺陷，我们可以采用集群的方法，增加服务器的数量，同时通过一个负载均衡服务器来分发用户请求即可。常见的硬件负载均衡器有：F5、A10
等，软件层面的负载均衡服务器包括 LVS、Nginx、HAproxy
等。集群服务器模型的结构则如下图所示：</p>
<p><img data-src="/images/apollo/cluster_model.png" width="60%" height="60%"/></p>
<p>对于集群服务器模型而言，它解决了硬件资源受限所导致的用户并发量问题，此外如果其中一台服务器挂掉，还有另外其它几台服务器可以正常提供服务。但是对于项目编译、部署的问题而言，却并未得到改善，项目要分别在每个机器上进行编译、部署，反而变得更加麻烦了。对于不同模块对于硬件资源的需求也并未得到解决。此外，对于一些并发量较低的模块，可能并不需要做到高并发，也就无需通过负载均衡器将用户请求分发到不同的服务器中，但是对于集群模型而言，每一个模块之间都是均衡的，并未做到模块的特化。</p>
<p>为了改进上述缺点，我们需要将其改进为分布式模型，其结构如下图所示。即将不同的模块部署在不同的服务器上，同时对于并发量较大的模块，我们可以通过集群部署来提升它的并发量，此外对于不同的模块，也可以提供不同的硬件资源，同时修改一个模块的代码也无需再编译整个项目，仅仅编译该模块即可：</p>
<p><img data-src="/images/apollo/distributed_model.png" width="75%" height="75%"/></p>
<p>总结而言，集群和分布式的区别如下：</p>
<ul>
<li><strong>集群</strong>：每一台服务器独立运行一个工程的所有模块。</li>
<li><strong>分布式</strong>：一个工程拆分了很多模块，每一个模块独立部署运行在一个服务器主机上，所有服务器协同工
作共同提供服务，每一台服务器称作分布式的一个节点，根据节点的并发要求，对一个节点可以再做节点模块集群部署。</li>
</ul>
<h2 id="rpc">2. RPC</h2>
<p>尽管分布式模型存在许多优点，但是考虑如下场景：用户正在访问用户管理模块，此时需要获取所有的好友信息，那么需要用到好友管理模块的内容。但是由于分布式部署的原因，用户管理模块和好友管理模块部署在不同的两个分布式节点上，即两台主机上。此时用户管理主机应该如何调用好友管理主机上的相应的业务方法？</p>
<p>这时就需要使用到 RPC
方法，为使用者提供一种透明调用机制而不必显式的区分本地调用和远程调用。RPC
方法的交互过程如下图所示：</p>
<p><img data-src="/images/apollo/rpc_model.png"/></p>
<p>由于底层网络通信框架使用的是运输层协议，只能发送字节流，因此会涉及到对象的序列化/反序列化问题，即上图中所示的黄色部分，而常见的网络数据传输格式包括如下三种：</p>
<ul>
<li>XML：一种通用和轻量级的数据交换格式语言，是指可扩展标记语言以文本结构进行存储。</li>
<li>JSON：一种通用和轻量级的数据交换格式，也是以文本的结构进行存储，是一种简单的消息格式。JSON
作为数据包格式传输时具有更高的效率，这是因为 JSON 不像 XML
那样需要有严格的闭合标签，这就让有效数据量与总数据包比有着显著的提升，从而减少同等数据流量的情况下网络的传输压力。</li>
<li>Protobuf：是 Google
开发的一种独立和轻量级的数据交换格式，以二进制结构进行存储，用于不同服务之间序列化数据。它是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者序列化，可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</li>
</ul>
<p>而该项目便是使用 Protobuf
来进行消息的序列化和反序列化，同时使用其来实现RPC框架，其底层的通信流程如下图所示：</p>
<p><img data-src="/images/apollo/protobuf_process.png"/></p>
<p>此外，为了解决TCP的粘包问题，我们设计了如下格式的数据头用来传递服务名称、方法名称以及参数大小，通过该数据头部我们可以确定所要读取的数据长度：</p>
<figure class="highlight proto"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">RpcHeader</span> &#123;</span><br><span class="line">  <span class="type">bytes</span> service_name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">bytes</span> method_name = <span class="number">2</span>;</span><br><span class="line">  <span class="type">uint32</span> args_size = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，为了确定 RpcHeader 的长度，我们使用了固定的 4
个字节来存储消息头的长度。数据打包和解包的流程图如下所示：</p>
<p><img data-src="/images/apollo/pack_process.png"/></p>
<p><strong>打包流程</strong>：</p>
<ol type="1">
<li>序列化函数参数得到 argsStr，其长度为 argsSize；</li>
<li>打包 service_name、method_name 和 argsSize 得到 rpcHeader；</li>
<li>序列化 rpcHeader 得到 rpcHeaderStr，其长度为 headerSize；</li>
<li>将 headerSize 存储到数据包的前 4 个字节，后面的依次是 rpcHeaderStr
和 argsStr；</li>
<li>通过网络发送数据包；</li>
</ol>
<p><strong>解包流程</strong>：</p>
<ol type="1">
<li>通过网络接收数据包；</li>
<li>首先取出数据包的前 4 个字节，读取出 headerSize 的大小；</li>
<li>从第 5 个字节开始，读取 headerSize 字节大小的数据，即为 rpcHeaderStr
的内容；</li>
<li>反序列化 rpcHeaderStr，得到 service_name、method_name 和
argsSize；</li>
<li>从 4+headerSize 字节开始，读取 argsSize 字节大小的数据，即为 argsStr
的内容；</li>
<li>反序列化 argsStr 得到函数参数 args；</li>
</ol>
<h2 id="zookeeper">3. ZooKeeper</h2>
<p>在分布式应用中，为了能够知道自己所需的服务位于哪台主机上，我们需要一个服务注册与发现中心，这也就是该项目中的ZooKeeper。它是一种分布式协调服务，可以在分布式系统中共享配置，协调锁资源，提供命名服务。</p>
<p>Zookeeper通过树形结构来存储数据，它由一系列被称为<strong>ZNode</strong>的数据节点组成，类似于常见的文件系统。不过和常见的文件系统不同，Zookeeper将数据全量存储在内存中，以此来实现高吞吐，减少访问延迟，其结构如下图所示：</p>
<p><img data-src="/images/apollo/zookeeper_node.png" width="45%" height="45%"/></p>
<p>在 <code>ZkClient</code> 类中，调用 <code>start()</code> 方法创建
<code>zkHandler_</code> 句柄时，其调用过程如下图所示，由于
zookeeper_init
是异步方法，所以该函数返回后，并不代表句柄创建成功，它会在回调函数线程中调用所传入的回调函数，在该回调函数中我们可以来判断句柄是否创建成功，由于API调用线程阻塞于信号量处，所以在回调函数中如果句柄创建成功，则调用
<code>sem_post</code>
方法增加信号量，以通知API调用线程句柄创建成功：</p>
<p><img data-src="/images/apollo/zookeeper_process.png" width="50%" height="50%"/></p>
]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>内存池</tag>
        <tag>分布式</tag>
        <tag>异步日志</tag>
        <tag>网络通信</tag>
        <tag>Zookeeper</tag>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL锁机制</title>
    <url>/2022/12/22/MySQL%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p>MySQL锁机制探究</p>

</blockquote>
<h1 id="表级锁行级锁">1.表级锁&amp;行级锁</h1>
<p>数据库中的锁通常分为两种：</p>
<ul>
<li><strong>表级锁</strong>：对整张表加锁。开销小，加锁快，不会出现死锁。但是锁的粒度大，发生锁冲突的概率高，并发度低。</li>
<li><strong>行级锁</strong>：对某行记录加锁。开销大，加锁慢，会出现死锁。但是锁的粒度小，发生锁冲突的概率低，并发度高。</li>
</ul>
<h1 id="排它锁共享锁">2.排它锁&amp;共享锁</h1>
<ul>
<li><strong>排它锁</strong>(<code>Exclusive</code>)：又称为 X
锁，写锁；</li>
<li><strong>共享锁</strong>(<code>Shared</code>)：又称为 S
锁，读锁；</li>
</ul>
<p>X 锁和 S 锁之间具有如下关系：S-S 之间可以兼容，但是 X-S、S-X、X-X
之间是互斥的。</p>
<ul>
<li>一个事务对数据对象 O 加了 S 锁，可以对 O
进行读取操作但不能对其进行更新操作。加锁期间其它事务能对 O 加 S
锁但不能加 X 锁；</li>
<li>一个事务对数据对象 O 加了 X 锁，可以对 O
进行读取和更新。加锁期间其它事务不能对 O 加任何锁。</li>
</ul>
<p>可以通过 <code>SELECT ... LOCK IN SHARE MODE</code>
强制获取共享锁，通过 <code>SELECT ... FOR UPDATE</code> 获取排它锁。</p>
<h1 id="innodb行级锁">3.InnoDB行级锁</h1>
<h2 id="行级锁">行级锁</h2>
<p>InnoDB
存储引擎支持事务处理，表支持行级锁定，并发能力更好。使用的过程中应该注意以下
3 点：</p>
<ol type="1">
<li>InnoDB
行锁是通过<strong>给索引上的索引项加锁来实现的，而不是给表的行记录加锁实现的</strong>，这就意味着只有通过索引条件检索数据，InnoDB
才使用行级锁，否则 InnoDB 将使用表锁。</li>
<li>由于 InnoDB
的行锁实现是针对索引字段添加的锁，不是针对行记录加的锁，因此虽然访问的是
InnoDB
引擎下表的不同行，但是如果使用相同的索引字段作为过滤条件，依然会发生锁冲突，只能串行进行，不能并发进行。</li>
<li>即使 SQL 中使用了索引，但是经过 MySQL
的优化器后，如果认为全表扫描比使用索引效率更高，此时会放弃使用索引，因此也不会使用行锁，而是使用表锁，比如对一些很小的表，MySQL
就不会去使用索引。</li>
</ol>
<div class="note danger"><p>注意，如果过滤条件使用的是辅助索引，那么它会通过辅助索引树回表到主键索引树，来查找到该行内容以获取行锁。</p>
</div>
<h2 id="间隙锁">间隙锁</h2>
<p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB
会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做
"<strong>间隙(GAP)</strong>"，InnoDB 也会对这个 "间隙"
加锁，这种锁机制就是所谓的【间隙锁】。</p>
<p>举例来说， 假如 user 表中只有 101 条记录， 其 userid 的值分别是
1,2,...,100,101，对于下面的 SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM user WHERE userid &gt; 100 FOR UPDATE;</span><br></pre></td></tr></table></figure>
<p>它是一个范围条件的检索，InnoDB 不仅会对符合条件的 userid 值为 101
的记录加锁，也会对 userid 大于 101（但是这些记录并不存在）的 "间隙"
加锁，以防止其它事务在表的末尾增加数据。</p>
<p>InnoDB
使用间隙锁的目的，为了防止【幻读】，<strong>以满足串行化隔离级别的要求</strong>，对于上面的例子，要是不使用间隙锁，如果其他事务插入了
userid 大于 100
的任何记录，那么本事务如果再次执行上述语句，就会发生幻读。</p>
<p>现在有这样一张数据表，其中 uid 为自增的主键字段，同时 age
字段为辅助索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-----+-------------+-----+-----+</span><br><span class="line">| uid | name        | age | sex |</span><br><span class="line">+-----+-------------+-----+-----+</span><br><span class="line">|   1 | zhangsan    |  18 | M   |</span><br><span class="line">|   2 | gaoyang     |  20 | W   |</span><br><span class="line">|   3 | chenwei     |  22 | M   |</span><br><span class="line">|   4 | linfeng     |  21 | W   |</span><br><span class="line">|   5 | liuxiang    |  19 | W   |</span><br><span class="line">|   6 | niuer       |  17 | M   |</span><br><span class="line">|   7 | liuxiaohong |  28 | W   |</span><br><span class="line">|   8 | gaolishi    |  37 | M   |</span><br><span class="line">|   9 | yuanwei     |  13 | W   |</span><br><span class="line">+-----+-------------+-----+-----+</span><br><span class="line">9 rows in set (0.26 sec)</span><br></pre></td></tr></table></figure>
<p>那么辅助索引树的叶子节点所在层结构大致如下：</p>
<p><img data-src="/images/MySQL_Lock/leaf_node.png" style="zoom:50%"/></p>
<p>如果现在在事务中使用如下 SQL 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM student WHERE age&gt;21;</span><br></pre></td></tr></table></figure>
<p>那么间隙锁的情况如下图所示：</p>
<p><img data-src="/images/MySQL_Lock/gap_lock_1.png" style="zoom:50%"/></p>
<p>由于在辅助索引树中，如果辅助索引相同，那么会按照主键索引按照升序进行排列，因此如果现在在事务中插入一个新的记录，其
age 字段为 21，那么其主键字段会大于 4，则会插入到间隙锁 1
所在位置，但是由于间隙锁 1 的存在，则会导致插入失败。而如果插入的 age
字段值为 19，则会插入成功。</p>
<p>如果使用的是等值查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM student WHERE age=28;</span><br></pre></td></tr></table></figure>
<p>那么其间隙锁情况如下：</p>
<p><img data-src="/images/MySQL_Lock/gap_lock_2.png" style="zoom:50%"/></p>
<p>此时，插入【22, 36】之间的值都会被阻塞。</p>
<h2 id="意向共享锁意向排它锁">意向共享锁&amp;意向排它锁</h2>
<p>如果要获取一张表的共享锁 S 或者排它锁
X，首先需要确定这张表没有被其它事务获取或 X
锁。但是如果表中的数据过多，遍历所有数据来查看是否存在某行数据或者获取过行锁
X 锁或者整张表存在表锁 X
锁，效率就会下降，为了提高效率，因此便有了如下的两把锁：</p>
<ul>
<li><strong>意向共享锁(IS锁)</strong>：事务计划给记录加行共享锁，事务在给一行记录加共享锁前，必须先取得该表的
IS 锁。</li>
<li><strong>意向排他锁(IX锁)</strong>：事务计划给记录加行排他锁，事务在给一行记录加排他锁前，必须先取得该表的
IX 锁。</li>
</ul>
<p>X、S、IS 锁和 IX 锁之间的兼容性如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">X</th>
<th style="text-align: center;">IX</th>
<th style="text-align: center;">S</th>
<th style="text-align: center;">IS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>X</strong></td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>IX</strong></td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">✔️</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">✔️</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>S</strong></td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">✔️</td>
<td style="text-align: center;">✔️</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>IS</strong></td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">✔️</td>
<td style="text-align: center;">✔️</td>
<td style="text-align: center;">✔️</td>
</tr>
</tbody>
</table>
<div class="note danger"><blockquote>
<p>表格中的X和S指的是表锁，不是行锁！！！</p>
</blockquote>
</div>
<p>注意：</p>
<ol type="1">
<li>意向锁是由 InnoDB 存储引擎获取行锁之前自己获取的;</li>
<li>意向锁之间都是兼容的，不会产生冲突;</li>
<li>意向锁存在的意义是为了更高效的获取表锁;</li>
<li>意向锁是表级锁，协调表锁和行锁的共存关系。主要目的是显示事务正在锁定某行或者试图锁定某行;</li>
</ol>
<h1 id="innodb表级锁">4.InnoDB表级锁</h1>
<p>在绝大部分情况下都应该使用行锁，因为事务和行锁往往是选择 InnoDB
的理由，但个别情况下也使用表级锁；</p>
<ol type="1">
<li>事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间等待和锁冲突；</li>
<li>事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。</li>
</ol>
<p>常用的相关命令如下：</p>
<ul>
<li><code>LOCK TABLE user READ</code>: 读锁锁表</li>
<li><code>LOCK TABLE user WRITE</code>: 写锁锁表</li>
<li><code>COMMIT/ROLLBACK</code>: 事务提交或者回滚</li>
<li><code>UNLOCK TABLES</code>:
本身自带提交事务，释放线程占用的所有表锁</li>
</ul>
<h1 id="死锁">5.死锁</h1>
<p>MyISAM 表锁是 <code>deadlock free</code> 的， 这是因为 MyISAM
总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但在
InnoDB 中，除单个 SQL
组成的事务外，锁是逐步获得的，即锁的粒度比较小，这就决定了在 InnoDB
中发生死锁是可能的。</p>
<p>死锁问题一般都是我们自己的应用造成的，和多线程编程的死锁情况相似，大部分都是由于我们多个线程在获取多个锁资源的时候，获取的顺序不同而导致的死锁问题。因此我们应用在对数据库的多个表做更新的时候，不同的代码段，应对这些表按相同的顺序进行更新操作，以防止锁冲突导致死锁问题。</p>
<h1 id="锁优化">6.锁优化</h1>
<ol type="1">
<li>尽量使用较低的隔离级别;</li>
<li>设计合理的索引并尽量使用索引访问数据，使加锁更加准确，减少锁冲突的机会提高并发能力;</li>
<li>选择合理的事务大小，小事务发生锁冲突的概率小;</li>
<li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会;</li>
<li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响;</li>
<li>不要申请超过实际需要的锁级别;</li>
<li>除非必须，查询时不要显示加锁;</li>
</ol>
<h1 id="mvcc多版本并发控制">7.MVCC多版本并发控制</h1>
<p>MVCC
是<strong>多版本并发控制</strong>(<code>Multi-Version Concurrency Control</code>，简称
MVCC)，是 MySQL
中基于乐观锁理论实现隔离级别的方式，用于实现<strong>已提交读</strong>和<strong>可重复读</strong>隔离级别的实现，也经常称为多版本数据库。</p>
<p>MVCC
机制会生成一个数据请求时间点的一致性数据快照(<code>Snapshot</code>)，并用这个快照来提供一定级别(语句级或事务级)的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本(系统版本号和事务版本号)。</p>
<p>在 MVCC 多版本并发控制中，读操作可以分为两类：</p>
<ol type="1">
<li><strong>快照读</strong>(snapshot read):
读的是记录的可见版本，不用加锁。如 select;</li>
<li><strong>当前读</strong>(current read):
读取的是记录的最新版本，并且当前读返回的记录。如
insert，delete，update，select...lock in share, mode/for update</li>
</ol>
<p>MVCC
中的每一行记录实际上有多个版本，每个版本的记录除了数据本身之外，还增加了其它字段，比如：</p>
<ul>
<li><code>DB_TRX_ID</code>：用于记录当前事务ID</li>
<li><code>DB_ROLL_PTR</code>：指向 undo log 日志上数据的指针</li>
</ul>
<p>MVCC 对于已提交读和可重复读的不同点在于：</p>
<ul>
<li><strong>已提交读</strong>：每次执行语句的时候都重新生成一次快照(Read
View)，即每次 select 查询时。</li>
<li><strong>可重复读</strong>：同一个事务开始的时候生成一个当前事务全局性的快照(Read
View)，即第一次select查询时。</li>
</ul>
<p>快照内容的读取原则如下：</p>
<ul>
<li>版本未提交无法读取生成快照；</li>
<li>版本已提交，但是在快照创建后提交的，无法读取；</li>
<li>版本已提交，但是在快照创建前提交的，可以读取；</li>
<li>当前事务内自己的更新，可以读到；</li>
</ul>
<h1 id="myisam表级锁">8.MyISAM表级锁</h1>
<p>MyISAM存储引擎不支持事务处理，因此它的并发比较简单，只支持到表锁的粒度，粒度比较大，并发能力一般，但不会引起死锁的问题，它支持表级共享的读锁和互斥的写锁。</p>
<p>对 MyISAM
表的读操作（共享锁），不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对
MyISAM
表的写操作（排它锁），则会阻塞其他用户对同一表的读和写操作。MyISAM
表的读操作与写操作之间，以及写操作之间是串行的。MyISAM
在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT
等）前，会自动给涉及的表加写锁，这个过程并不需要用户控制，是 MySQL
Server 端自动完成的。</p>
<p>在 MyISAM
存储引擎下，多个线程并发操作时，线程1试图获取读锁，线程2获取写锁，一般
MyISAM
认为写操作要比读操作重要，因此线程2几乎都会优先获取写锁，写操作完成后，线程1才会获取读锁。即使线程1的读锁请求先到达，线程2的写锁请求后到达，那么线程2写锁的获取也会排在线程1读锁的前面。</p>
<p>因此，MyISAM
存储引擎不适合大量的更新操作和查询操作，因为查询操作获取读锁的优先级比较低，会导致客户端查询获取结果的过程很慢。当然
MySQL 提供了很多参数设置，可以调整读锁的获取优先级。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL日志</title>
    <url>/2022/12/22/MySQL%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p>MySQL日志机制探究</p>

</blockquote>
<h1 id="错误日志">1.错误日志</h1>
<p>错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld
启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，可以首先查看此日志。</p>
<p>mysqld 使用错误日志名 host_name.err 并默认在参数
DATADIR(数据目录)指定的目录中写入日志文件。</p>
<div class="note info"><p>host_name 为主机名。</p>
</div>
<h1 id="二进制日志">2.二进制日志</h1>
<p>二进制日志(BINLOG) 记录了所有的 DDL(数据定义语言)语句和
DML(数据操纵语言) 语句，但是不包括数据查询语句。语句以 “事件”
的形式保存，它描述了数据的更改过程。
此日志对于灾难时的数据恢复起着极其重要的作用。</p>
<p>它两个重要的应用场景：主从复制、数据恢复。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 查看binlog</span><br><span class="line">show binary logs;</span><br></pre></td></tr></table></figure>
<p>通过 MySQL 自带的 <code>mysqlbinlog</code> 工具可以快速解析大量的
binlog 日志文件，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlbinlog --no-defaults --database=school --base64-output=decode-rows</span><br><span class="line">-v --start-datetime=&#x27;2021-05-01 00:00:00&#x27; --stop-datetime=&#x27;2021-05-10 00:00:00&#x27;</span><br><span class="line">mysql-bin.000001 | more</span><br></pre></td></tr></table></figure>
<h1 id="查询日志">3.查询日志</h1>
<p>查询日志记录了客户端的所有语句。由于上线项目 SQL
语句特别多，开启查询日志 IO 太多导致 MySQL
效率低，只有在调试时才开启，比如通过查看 SQL
语句发现热点数据进行缓存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show global variables like &quot;%genera%&quot;;</span><br></pre></td></tr></table></figure>
<h1 id="慢查询日志">4.慢查询日志</h1>
<p>MySQL 可以设置慢查询日志，当 SQL
执行的时间超过我们设定的时间，那么这些 SQL
就会被记录在慢查询日志当中，然后我们通过查看日志，用
<code>explain</code> 分析这些 SQL
的执行计划，来判定为什么效率低下，是没有使用到索引？还是索引本身创建的有问题？或者是索引使用到了，但是由于表的数据量太大，花费的时间就是很长，那么此时我们可以把表分成
n 个小表，比如订单表按年份分成多个小表等。</p>
<p>慢查询日志的相关参数如下所示：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="section">mysql&gt; show variables like &#x27;%slow_query%&#x27;;</span></span><br><span class="line"><span class="section">+---------------------+--------------------------------------------+</span></span><br><span class="line"><span class="section">| Variable_name       | Value                                      |</span></span><br><span class="line"><span class="section">+---------------------+--------------------------------------------+</span></span><br><span class="line">| slow<span class="emphasis">_query_log      | OFF                                        |</span></span><br><span class="line"><span class="emphasis">| slow_query_log_</span>file | E:\Application\MySQL\data\XiaoXin-slow.log |</span><br><span class="line"><span class="code">+---------------------+</span>--------------------------------------------+</span><br><span class="line">2 rows in set, 1 warning (1.26 sec)</span><br></pre></td></tr></table></figure>
<p>慢查询日志记录了包含所有执行时间超过参数
<code>long_query_time</code>(单位：秒) 所设置值的 SQL 语句的日志，在
MySQL 上用命令可以查看，如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="section">mysql&gt; show variables like &#x27;long%&#x27;;</span></span><br><span class="line"><span class="section">+-----------------+-----------+</span></span><br><span class="line"><span class="section">| Variable_name   | Value     |</span></span><br><span class="line"><span class="section">+-----------------+-----------+</span></span><br><span class="line"><span class="section">| long_query_time | 10.000000 |</span></span><br><span class="line"><span class="section">+-----------------+-----------+</span></span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>这个值是可以修改的，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET long_query_time = 1;</span><br></pre></td></tr></table></figure>
<p>现在修改成超过 1 秒的 SQL 都会被记录在慢查询日志当中！可以设置为 0.01
秒，表示 10 毫秒。慢查询日志，默认名称是
<code>host_name-slow.log</code>，存放在 MySQL
的数据路径下，内容格式显示大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Query_time: 0.012000 Lock_time: 0.000000 Rows_sent: 0 Rows_examined: 139</span><br><span class="line">use tuluneducation;</span><br><span class="line">SET timestamp=1534527397;</span><br><span class="line">select id,author from subject where content like &#x27;%linux%&#x27; and title like &#x27;%c++</span><br><span class="line">linux%&#x27;;</span><br></pre></td></tr></table></figure>
<p>通过查询慢查询日志，发现项目运行过程中，上面这条 SQL
语句的执行时间超过了设定的慢查询时间，那么接下来就需要用
<code>explain</code> 分析一下该 SQL 的执行细节了，根据具体情况找出 SQL
和MySQL 索引|索引该怎么去优化。</p>
<div class="note info"><p><code>show profiles</code> 命令可以查看 SQL
语句具体的运行时间，全局变量的名字是: <code>profiling</code>。</p>
</div>
<h1 id="redoundo">5.redo&amp;undo</h1>
<h2 id="redo-log">redo log</h2>
<p>redo log
是<strong>重做日志</strong>，用于记录事务操作的变化，确保事务的持久性。redo
log
是在事务开始后就开始记录，不管事务是否提交都会记录下来，在异常发生时（如数据持久化过程中掉电），InnoDB
会使用 redo log 恢复到掉电前的时刻，保证数据的完整性。</p>
<p><code>innodb_log_buffer_size</code> 默认是 16M，就是 redo log
缓冲区的大小，它随着事务开始，就开始写 redo
log，如果事务比较大，为了避免事务执行过程中花费过多磁盘
IO，可以设置比较大的 redo log 缓存，节省磁盘IO。InnoDB
修改操作数据，不是直接修改磁盘上的数据，实际只是修改 Buffer Pool
中的数据。InnoDB 总是先把 Buffer Pool 中的数据改变记录到 redo log
中，用来进行崩溃后的数据恢复。优先记录 redo log，然后再慢慢的将 Buffer
Pool 中的脏数据刷新到磁盘上。</p>
<p><code>innodb_log_group_home_dir</code>
指定的目录下的两个文件：<code>ib_logfile0</code>，<code>ib_logfile1</code>，该文件被称作重做
日志。</p>
<p>buffer pool 缓存池的作用：加速读和加速写，直接操作 data page，写 redo
log 修改就算完成，有专门的线程去做把 buffer pool中的 dirty page
写入磁盘。</p>
<p><img data-src="/images/MySQL_Log/log_process.png" style="zoom:40%"/></p>
<h2 id="undo-log">undo log</h2>
<p><code>undo log</code>
是回滚日志，保存了事务发生之前的数据的一个版本，用于事务指向时的回滚操作，同时也是实现多版本并发控制(MVCC)下读操作的关键技术。</p>
<p>其过程如下图所示，其中 <code>DB_TRX_ID</code> 为事务
ID，<code>DB_ROLL_PTR</code> 为回滚指针：</p>
<p><img data-src="/images/MySQL_Log/undo_log.png" style="zoom:50%"/></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引底层原理</title>
    <url>/2022/11/10/MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p>MySQL索引底层原理探究</p>

</blockquote>
<h2 id="索引原理">索引原理</h2>
<p>这里主要讨论一下 MySQL InnoDB
存储引擎，基于B-树（但实际上MySQL采用的是B+树结构）的索引结构。</p>
<p>一次索引的过程大致如下图所示：</p>
<p><img data-src="/images/MySQL_Index/index_process.png" style="zoom:40%"/></p>
<p>首先来看一下磁盘的结构，其示意图如下所示：</p>
<p><img data-src="/images/MySQL_Index/disk.jpg" style="zoom:50%"/></p>
<p>读/写磁盘某一位置的步骤如下：</p>
<ol type="1">
<li>首先根据柱面号，移动读写磁头，使磁头移动到相应的柱面上，这一过程被称为定位或查找；</li>
<li>所有磁头都定位到柱面号对应的磁道上后，这时根据盘面号来确定指定盘面号上的具体磁道；</li>
<li>盘面确定后，盘片开始旋转，将指定扇区号的磁道段移动至读写磁头下；</li>
</ol>
<p>经过以上步骤，指定数据的存储位置就被找到了，这时就可以开始读/写操作了。</p>
<p>可以看到，磁盘 I/O
依靠的是机械运动，其性能所在主要分为如下三个指标：</p>
<ul>
<li><strong>寻道时间(seek)</strong>:
指将读写磁头移动到指定磁道上所需要的时间，这部分时间代价最高；</li>
<li><strong>旋转延迟时间(rotation)</strong>:
指磁盘旋转将目标扇区移动到读写磁头下方所需的时间，其取决于磁盘的转速；</li>
<li><strong>数据传输时间(transfer)</strong>:
指完成数据传输所需的时间，其取决于接口的数据传输速率；</li>
</ul>
<p>对于操作系统来说，当程序需要读取的数据不在内存中时，这时就会触发一个<strong>缺页中断</strong>，那么系统就会向磁盘发出读信号，磁盘会按照
Block 进行读取，将其载入内存，通常一个 Block 为 16K。</p>
<p>在操作系统的内存管理机制中，它是以 Page 为单位的，通常为 4K 或
16K，而一个 Block 的大小则是 Page 的整数倍。</p>
<p>假设现在从磁盘上读取了 2000 万的索引到内存上，如果使用 AVL
二叉平衡树来存储，如图所示：</p>
<p><img data-src="/images/MySQL_Index/avl_tree.png" style="zoom:25%"/></p>
<p>其中，每个二叉树节点只能存储一个索引，那么其树高大约为 <span
class="math inline">\(log_220000000\approx25\)</span>，也就是说，如果在最坏的情况下，即每一层的节点都位于不同的
Block 中，那么总共需要 25 次磁盘 IO 操作。</p>
<p>而 B- 树则是一个 m 阶的平衡树，通常 m 取 300~500，即一个节点下有 m
个子节点。如果使用 B- 树的结构来进行存储，假如此时 m 取
500，那么其树高大约为 <span
class="math inline">\(log_m20000000=log_{500}20000000\approx3\)</span>，也就是说，在最坏的情况下，只需要
3 次磁盘 I/O 操作即可完成。通常 m 的大小取值取决于一次磁盘 I/O
操作所读取的内容能刚好存储在一个节点中。</p>
<p><img data-src="/images/MySQL_Index/b_tree.png"/></p>
<p>从上图可以看到B-树存在的缺点：</p>
<ul>
<li>每个节点中有 Key，也有 Data，但是每一个节点的存储空间是有限的，如果
Data 数据较大时会导致每个节点能存储的 Key 的数据很小；</li>
<li>当存储的数据量很大时同样会导致B-树的高度较大，磁盘 IO
次数花费增大，效率降低；</li>
</ul>
<p>因此针对如上缺点做出了优化，形成了B+树的数据结构，如图所示：</p>
<p><img data-src="/images/MySQL_Index/B+Tree.png"/></p>
<p>那么 MySQL
最终为什么要采用B+树存储索引结构呢，那么看看B-树和B+树在存储结构上有什么不同？</p>
<ol type="1">
<li>B-树的每一个节点，存了关键字和对应的数据地址，而B+树的非叶子节点只存关键字，不存数据地址。因此B+树的每一个非叶子节点存储的关键字是远远多于B-树的，B+树的叶子节点存放关键字和数据，因此，从树的高度上来说，B+树的高度要小于B-树，使用的磁盘
I/O 次数少，因此查询会更快一些。</li>
<li>B-树由于每个节点都存储关键字和数据，因此离根节点进的数据，查询的就快，离根节点远的数据，查询的就慢；B+树所有的数据都存在叶子节点上，因此在B+树上搜索关键字，找到对应数据的时间是比较平均的，没有快慢之分。</li>
<li>在B-树上如果做区间查找，遍历的节点是非常多的；B+树所有叶子节点被连接成了有序链表结构，因此做整表遍历和区间查找是非常容易的。</li>
</ol>
<p>现在有这样一张数据表：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">mysql&gt; select <span class="symbol">*</span> from student;</span><br><span class="line">+-----+-------------+-----+-----+</span><br><span class="line">|<span class="string"> uid </span>|<span class="string"> name        </span>|<span class="string"> age </span>|<span class="string"> sex </span>|</span><br><span class="line">+-----+-------------+-----+-----+</span><br><span class="line">|<span class="string">   1 </span>|<span class="string"> zhangsan    </span>|<span class="string">  18 </span>|<span class="string"> M   </span>|</span><br><span class="line">|<span class="string">   2 </span>|<span class="string"> gaoyang     </span>|<span class="string">  20 </span>|<span class="string"> W   </span>|</span><br><span class="line">|<span class="string">   3 </span>|<span class="string"> chenwei     </span>|<span class="string">  22 </span>|<span class="string"> M   </span>|</span><br><span class="line">|<span class="string">   4 </span>|<span class="string"> linfeng     </span>|<span class="string">  21 </span>|<span class="string"> W   </span>|</span><br><span class="line">|<span class="string">   5 </span>|<span class="string"> liuxiang    </span>|<span class="string">  19 </span>|<span class="string"> W   </span>|</span><br><span class="line">|<span class="string">   6 </span>|<span class="string"> niuer       </span>|<span class="string">  17 </span>|<span class="string"> M   </span>|</span><br><span class="line">|<span class="string">   7 </span>|<span class="string"> liuxiaohong </span>|<span class="string">  28 </span>|<span class="string"> W   </span>|</span><br><span class="line">|<span class="string">   8 </span>|<span class="string"> gaolishi    </span>|<span class="string">  37 </span>|<span class="string"> M   </span>|</span><br><span class="line">|<span class="string">   9 </span>|<span class="string"> yuanwei     </span>|<span class="string">  13 </span>|<span class="string"> W   </span>|</span><br><span class="line">+-----+-------------+-----+-----+</span><br></pre></td></tr></table></figure>
<p>其中，主键字段为
uid，那么对于不同的业务场景，其查询的方式是不同的。</p>
<h3 id="情况1">情况1</h3>
<p>查询语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM student WHERE uid=5;</span><br></pre></td></tr></table></figure>
<p>使用 <code>explain</code> 关键字查看该语句的搜索细节如下：</p>
<p><img data-src="/images/MySQL_Index/result_1.png"/></p>
<p>观察 <code>type</code>
字段可知该查询为<strong>常值查询</strong>，<code>rows</code>
字段则表示该查询只遍历了 1 行，也就是从 B+ 树的根节点开始进行搜索：</p>
<p><img data-src="/images/MySQL_Index/case_1.png" style="zoom:50%"/></p>
<h3 id="情况2">情况2</h3>
<p>查询语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM student WHERE uid&lt;5;</span><br></pre></td></tr></table></figure>
<p>使用 <code>explain</code> 关键字查看该语句的搜索细节如下：</p>
<p><img data-src="/images/MySQL_Index/result_2.png"/></p>
<p>观察 <code>type</code>
字段可知该查询为<strong>范围查询</strong>，<code>rows</code>
字段则表示该查询遍历了 4 行，也就是从 B+
树的叶子节点所在层的双向链表进行查询：</p>
<p><img data-src="/images/MySQL_Index/case_2.png" style="zoom:50%"/></p>
<h3 id="情况3">情况3</h3>
<p>查询语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM student WHERE name=&#x27;linfeng&#x27;;</span><br></pre></td></tr></table></figure>
<p>使用 <code>explain</code> 关键字查看该语句的搜索细节如下：</p>
<p><img data-src="/images/MySQL_Index/result_3.png"/></p>
<p>观察 <code>type</code>
字段可知该查询为<strong>整表查询</strong>，<code>rows</code>
字段则表示该查询遍历了该表的所有行，这是因为所查询的 <code>name</code>
字段并不存在索引。也就是从 B+
树的叶子节点所在层的双向链表进行查询，且遍历整个链表。</p>
<h3 id="情况4">情况4</h3>
<p>现在使用如下语句为 <code>name</code>
字段添加索引，将其设置为普通索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index nameidx on student(name);</span><br></pre></td></tr></table></figure>
<p>查看所有是否创建正确：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> student\G</span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">       <span class="keyword">Table</span>: student</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span>: <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">  `uid` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `<span class="type">name</span>` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` tinyint unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `sex` enum(<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;W&#x27;</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`uid`),</span><br><span class="line">  KEY `nameidx` (`<span class="type">name</span>`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=<span class="number">10</span> <span class="keyword">DEFAULT</span> CHARSET=utf8mb3</span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>现在该表中就会存在两个索引，一个是主键默认创建的<strong>主键索引</strong>，另一个则是刚才所创建的<strong>普通索引</strong>，也称为<strong>辅助索引</strong>。那么在构建
B+ 树时，会不但会构建主键索引的 B+ 树，还会构建辅助索引的 B+
树，且在辅助索引的 B+ 树的节点中的 data 存放的便是主键字段。</p>
<p><img data-src="/images/MySQL_Index/index_node.png" style="zoom:50%"/></p>
<p>现在执行如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT uid FROM student WHERE name=&quot;linfeng&quot;;</span><br></pre></td></tr></table></figure>
<p>使用 <code>explain</code> 关键字查看该语句的搜索细节如下：</p>
<p><img data-src="/images/MySQL_Index/result_4.png"/></p>
<p>观察 <code>Extra</code>
字段可知，其查询是通过二级索引树进行查找。</p>
<h3 id="情况5">情况5</h3>
<p>现在执行如下 SQL 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM student WHERE name=&quot;linfeng&quot;;</span><br></pre></td></tr></table></figure>
<p>使用 <code>explain</code> 关键字查看该语句的搜索细节如下：</p>
<p><img data-src="/images/MySQL_Index/result_5.png"/></p>
<p>与上述一种情况不同的是，此次查询的 <code>Extra</code> 字段变为了
NULL，这时因为在二级索引树上查找目标值只能得到其主键值，而现在需要主键值所在行的所有数据，那么需要执行如下过程：</p>
<ol type="1">
<li>现在二级索引树上根据普通索引查找得到主键值；</li>
<li>然后在主键索引树上根据刚才得到的主键值进行查找得到所有数据；</li>
</ol>
<p>如上过程称之为
<strong>回表</strong>。所以，如果发生回表操作，也就会产生更多的查找和磁盘
I/O 操作，会更耗时。</p>
<h2 id="聚集索引和非聚集索引">聚集索引和非聚集索引</h2>
<p>在 MyISAM
引擎中，由于索引和数据存储在不同的两个文件中，所以其主键索引树和二级索引树是一样的，即二级索引树叶子节点中的数据是整行数据，而非主键值。称这种索引为
<strong>非聚集索引</strong>。而 InnoDB 引擎中的索引则称为
<strong>聚集索引</strong>。</p>
<h3 id="myisam">MyISAM</h3>
<p>MyISAM 引擎使用 B+ 树作为索引结构，叶节点的 Data
域存放的是数据记录的地址。下图是 MyISAM 主键索引的原理图：</p>
<p><img data-src="/images/MySQL_Index/myisam_primary_key.png" style="zoom:40%"/></p>
<p>在 MyISAM
中，主键索引和辅助索引(<code>Secondary key</code>)在结构上没有任何区别，只是主键索引要求
Key 是唯一的，而辅助索引的 Key
可以重复，如果给其它字段创建辅助索引，其结构图如下：</p>
<p><img data-src="/images/MySQL_Index/myisam_secondary_key.png" style="zoom:40%"/></p>
<p>根据上面两张图，首先按照 B+ Tree 搜索算法搜索索引，如果指定的 Key
存在，则取出其 Data 域的值，然后以 Data
域的值为地址，读取相应数据记录。</p>
<p>可以看到，MyISAM
存储引擎，索引结构叶子节点存储关键字和数据地址，也就是说索引关键字和数据没有在一起存放，体现在磁盘上，就是索引在一个文件存储，数据在另一个文件存储，例如一个
user 表，会在磁盘上存储为三个文件：</p>
<ul>
<li>user.frm（表结构文件）</li>
<li>user.MYD（表的数据文件）</li>
<li>user.MYI（表的索引文件）</li>
</ul>
<p>MyISAM 的索引方式也叫做<strong>非聚集索引</strong>。</p>
<h3 id="innodb">InnoDB</h3>
<p>在 InnoDB
存储引擎的主键索引树的叶子节点中，索引关键字和数据是在一起存放的，其结构如图所示：</p>
<p><img data-src="/images/MySQL_Index/innodb_primary_key.png" style="zoom:40%"/></p>
<p>对于 InnoDB
的辅助索引树而言，其叶子节点上存放的是索引关键字和对应的主键，其结构如图所示：</p>
<p><img data-src="/images/MySQL_Index/innodb_secondary_key.png" style="zoom:40%"/></p>
<p>在辅助索引的 B+
树中，会先根据关键字找到对应的主键，然后再去主键索引树上找到对应的行记录数据。从索引树上可以看到，InnoDB
的索引关键字和数据都是在一起存放的，体现在磁盘存储上，例如创建一个 user
表，在磁盘上只存储两种文件：</p>
<ul>
<li>user.frm（存储表的结构）</li>
<li>user.ibd（存储索引和数据）</li>
</ul>
<p>InnoDB
的索引树叶节点包含了完整的数据记录，这种索引叫做<strong>聚集索引</strong>。因为
InnoDB 的数据文件本身要按主键聚集，所以 InnoDB
要求表必须有主键（区别于MyISAM可以没有），如果没有显式指定，则 MySQL
系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则
MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6
个字节，类型为长整形。</p>
<h2 id="自适应哈希索引">自适应哈希索引</h2>
<p>对于 InnoDB
存储引擎来说，如果它检测到同一个二级索引树不断被使用，那么该引擎会在内存上根据二级索引树上的二级索引值，在内存上构建一个哈希表，以此来减少回表的次数以加速搜索。</p>
<p><img data-src="/images/MySQL_Index/adaptive_hash_index.png" style="zoom:40%"/></p>
<p><strong>注意</strong>：自适应哈希索引本身的数据维护也是需要耗费性能的，并不是说自适应哈希索引在任何情况下都会提升二级索引的查询性能。</p>
<p>官方文档的解释如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">In MySQL 5.7, the adaptive hash index search system is partitioned. Each index is bound to a specific partition, and each partition is protected by a separate latch. Partitioning is controlled by the innodb_adaptive_hash_index_parts configuration option. </span><br><span class="line"></span><br><span class="line">In earlier releases, the adaptive hash index search system was protected by a single latch which could become a point of contention under heavy workloads. The innodb_adaptive_hash_index_parts option is set to 8 by default. The maximum setting is 512.</span><br><span class="line"></span><br><span class="line">The hash index is always built based on an existing B-tree index on the table. InnoDB can build a hash index on a prefix of any length of the key defined for the B-tree, depending on the pattern of searches that InnoDB observes for the B-tree index.  A hash index can be partial, covering only those pages of the index that are often accessed.</span><br><span class="line"></span><br><span class="line">You can monitor the use of the adaptive hash index and the contention for its use in the SEMAPHORES section of the output of the SHOW ENGINE INNODB STATUS command. If you see many threads waiting on an RW-latch created in btr0sea.c, then it might be useful to disable adaptive hash indexing.</span><br></pre></td></tr></table></figure>
<p>简单来说，就是在 MySQL 5.7
版本后，自适应哈希索引搜索系统会被分区，在默认情况下，自适应哈希索引搜索系统是开启的，由
<code>innodb_adaptive_hash_index</code> 变量来进行控制。在默认情况下会有
8 个分区，由 <code>innodb_adaptive_hash_index_part</code>
变量来进行控制，最大值为 512。</p>
<p>在每个分区中都会有一个单独的锁来控制并发操作，而在 5.7
版本之前，只使用了一个锁来保护整个哈希索引搜索系统，这会成为系统的瓶颈所在。</p>
<p>此外，哈希索引可能只构建了部分内存，仅仅包括那些经常访问到的页面。如果哈希索引搜索系统成为了系统的瓶颈，那么就可以考虑将其关闭而提高性能。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>B+树</tag>
      </tags>
  </entry>
</search>
