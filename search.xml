<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Nginx内存池源码剖析</title>
    <url>/2022/12/20/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p>Nginx 内存池源码剖析</p>

</blockquote>
<p><a href="http://nginx.org/">Nginx</a> 源码版本: 1.13.1</p>
<p>Nginx 内存池的定义主要位于如下两个文件中：</p>
<ul>
<li>ngx_palloc.h</li>
<li>ngx_palloc.c</li>
</ul>
<p>首先是几个重要的宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NGX_MAX_ALLOC_FROM_POOL  (ngx_pagesize - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NGX_DEFAULT_POOL_SIZE    (16 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NGX_POOL_ALIGNMENT       16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NGX_MIN_POOL_SIZE                                                     \</span></span><br><span class="line"><span class="meta">    ngx_align((sizeof(ngx_pool_t) + 2 * sizeof(ngx_pool_large_t)),            \</span></span><br><span class="line"><span class="meta">              NGX_POOL_ALIGNMENT)</span></span><br></pre></td></tr></table></figure>
<p>它们的含义分别如下：</p>
<ul>
<li><code>NGX_MAX_ALLOC_FROM_POOL</code>:
最多可以从内存池中取得的大小，在 x86 机器上为 4095</li>
<li><code>NGX_DEFAULT_POOL_SIZE</code>: 默认的内存池大小，16K</li>
<li><code>NGX_POOL_ALIGNMENT</code>: 内存池字节对齐相关</li>
<li><code>NGX_MIN_POOL_SIZE</code>: 最小的内存池大小</li>
</ul>
<p>其中的 <code>ngx_align</code> 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_align(d, a)     (((d) + (a - 1)) &amp; ~(a - 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_align_ptr(p, a)                                                   \</span></span><br><span class="line"><span class="meta">    (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) &amp; ~((uintptr_t) a - 1))</span></span><br></pre></td></tr></table></figure>
<p>上述两个宏函数的作用分别是：(1) 将数值 d 调整到 a 的临近倍数；(2)
将指针 p 调整到 a 的临近倍数。类似于 <code>SGI STL</code>
中的位运算设计。</p>
<p>然后介绍几个重要的数据类型，它们被用来表示内存池的头部信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u_char               *last;</span><br><span class="line">    u_char               *end;</span><br><span class="line">    <span class="type">ngx_pool_t</span>           *next;</span><br><span class="line">    <span class="type">ngx_uint_t</span>            failed;</span><br><span class="line">&#125; <span class="type">ngx_pool_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> &#123;</span></span><br><span class="line">    <span class="type">ngx_pool_data_t</span>       d;</span><br><span class="line">    <span class="type">size_t</span>                max;</span><br><span class="line">    <span class="type">ngx_pool_t</span>           *current;</span><br><span class="line">    <span class="type">ngx_chain_t</span>          *chain;</span><br><span class="line">    <span class="type">ngx_pool_large_t</span>     *large;</span><br><span class="line">    <span class="type">ngx_pool_cleanup_t</span>   *cleanup;</span><br><span class="line">    <span class="type">ngx_log_t</span>            *<span class="built_in">log</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> <span class="title">ngx_pool_t</span>;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="/images/NginxMemoryPool/ngx_pool_s.png" style="zoom:70%"/></p>
<h1 id="调整内存边界">1. 调整内存边界</h1>
<p>函数 <code>ngx_memalign</code> 是一个调整内存对齐的函数，分为 Windows
平台和 Unix 两种平台实现，其中 Unix 平台下的实现如下，通过两个宏
<code>NGX_HAVE_POSIX_MEMALIGN</code> 和 <code>NGX_HAVE_MEMALIGN</code>
进行控制：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Linux has memalign() or posix_memalign()</span></span><br><span class="line"><span class="comment"> * Solaris has memalign()</span></span><br><span class="line"><span class="comment"> * FreeBSD 7.0 has posix_memalign(), besides, early version&#x27;s malloc()</span></span><br><span class="line"><span class="comment"> * aligns allocations bigger than page size at the page boundary</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_HAVE_POSIX_MEMALIGN || NGX_HAVE_MEMALIGN)</span></span><br><span class="line">	<span class="type">void</span> *<span class="title function_">ngx_memalign</span><span class="params">(<span class="type">size_t</span> alignment, <span class="type">size_t</span> size, <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ngx_memalign(alignment, size, log)  ngx_alloc(size, log)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>其中的 <code>ngx_alloc</code>
函数实现如下，可以看到，其内部实现实际上调用的就是 <code>malloc</code>
函数来分配动态内存：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">ngx_alloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span> &#123;</span><br><span class="line">    <span class="type">void</span>  *p;</span><br><span class="line">    p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">&quot;malloc(%uz) failed&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, <span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;malloc: %p:%uz&quot;</span>, p, size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果定义了 <code>NGX_HAVE_POSIX_MEMALIGN</code>
宏，则会调用如下函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">ngx_memalign</span><span class="params">(<span class="type">size_t</span> alignment, <span class="type">size_t</span> size, <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span> &#123;</span><br><span class="line">    <span class="type">void</span>  *p;</span><br><span class="line">    <span class="type">int</span>    err;</span><br><span class="line">    err = posix_memalign(&amp;p, alignment, size);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, err, <span class="string">&quot;posix_memalign(%uz, %uz) failed&quot;</span>, alignment, size);</span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ngx_log_debug3(NGX_LOG_DEBUG_ALLOC, <span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;posix_memalign: %p:%uz @%uz&quot;</span>, p, size, alignment);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果定义了 <code>NGX_HAVE_MEMALIGN</code> 宏，则会调用如下函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">ngx_memalign</span><span class="params">(<span class="type">size_t</span> alignment, <span class="type">size_t</span> size, <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span> &#123;</span><br><span class="line">    <span class="type">void</span>  *p;</span><br><span class="line">    p = memalign(alignment, size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">&quot;memalign(%uz, %uz) failed&quot;</span>, alignment, size);</span><br><span class="line">    &#125;</span><br><span class="line">    ngx_log_debug3(NGX_LOG_DEBUG_ALLOC, <span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;memalign: %p:%uz @%uz&quot;</span>, p, size, alignment);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上两个函数会根据传入的 <code>alignment</code>
函数参数进行字节对齐。</p>
<h1 id="创建内存池">2. 创建内存池</h1>
<p>首先来看一下函数
<code>ngx_create_pool</code>，其作用是创建一个内存池，其源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ngx_pool_t</span>* <span class="title function_">ngx_create_pool</span><span class="params">(<span class="type">size_t</span> size, <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span> &#123;</span><br><span class="line">    <span class="type">ngx_pool_t</span>  *p;</span><br><span class="line">    </span><br><span class="line">    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, <span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p-&gt;d.last = (u_char *) p + <span class="keyword">sizeof</span>(<span class="type">ngx_pool_t</span>);</span><br><span class="line">    p-&gt;d.end = (u_char *) p + size;</span><br><span class="line">    p-&gt;d.next = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    size = size - <span class="keyword">sizeof</span>(<span class="type">ngx_pool_t</span>);</span><br><span class="line">    p-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line">    </span><br><span class="line">    p-&gt;current = p;</span><br><span class="line">    p-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;cleanup = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;<span class="built_in">log</span> = <span class="built_in">log</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数根据用户传入的 <code>size</code> 大小来开辟内存池，首先调用了
<code>ngx_memalign</code>
函数来进行字节对齐和动态内存分配，字节对齐使用的是上方的
<code>NGX_POOL_ALIGNMENT</code>
宏。同时可以根据不同的平台所定义的宏来调用不同的内存分配函数，如果没有相关的宏，则实质调用的是
<code>malloc</code> 函数来进行动态内存分配。</p>
<p>然后，分别初始化
<code>d.last</code>、<code>d.end</code>、<code>d.next</code> 和
<code>d.failed</code>，可以看出来，<code>d.last</code>
指向了内存池头部信息的末尾位置，<code>d.end</code>
则指向了内存池的最末尾位置，如下图所示：</p>
<p><img data-src="/images/NginxMemoryPool/ngx_struct_1.png" style="zoom:60%"/></p>
<p>然后通过用 <code>size</code>
减去内存池头部数据的长度，得到内存池的可用空间大小。而 <code>max</code>
则调整为 <code>size</code> 和 <code>NGX_MAX_ALLOC_FROM_POOL</code>
的最小值，保证内存池的最大容量不超过一页。然后 <code>current</code>
指针则指向了当前内存池的起始地址，示意图如下：</p>
<p><img data-src="/images/NginxMemoryPool/ngx_struct_2.png" style="zoom:60%"/></p>
<p>创建成功后，返回内存池头部地址即可。其它头部信息后面再说。</p>
<h1 id="向内存池申请内存">3. 向内存池申请内存</h1>
<p>如果需要向内存池申请内存，则可用调用如下几个函数：</p>
<p>函数 <code>ngx_palloc</code> 的作用是向内存池申请 <code>size</code>
大小的内存，同时使用字节对齐:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">ngx_palloc</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !(NGX_DEBUG_PALLOC)</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool-&gt;max) &#123;</span><br><span class="line">        <span class="keyword">return</span> ngx_palloc_small(pool, size, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ngx_palloc_large(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数 <code>ngx_pnalloc</code> 的作用是向内存池申请 <code>size</code>
大小的内存，但不使用字节对齐：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">ngx_pnalloc</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !(NGX_DEBUG_PALLOC)</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool-&gt;max) &#123;</span><br><span class="line">        <span class="keyword">return</span> ngx_palloc_small(pool, size, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ngx_palloc_large(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数 <code>ngx_pcalloc</code>
的作用是先申请内存，然后对内存块清零：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">ngx_pcalloc</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">void</span> *p;</span><br><span class="line">    p = ngx_palloc(pool, size);</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        ngx_memzero(p, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上可以看到，向内存池申请内存时，Nginx 会根据用户传入的
<code>size</code> 参数来选择调用 <code>ngx_palloc_small</code> 函数和
<code>ngx_palloc_large</code>
函数，前者用来申请小块内存，后者用来申请大块内存，可以看到，小块内存和大块内存的分界线便是头部信息中的
<code>max</code> 参数。</p>
<h1 id="申请小块内存">4. 申请小块内存</h1>
<p>如果申请的是小块内存，则调用 <code>ngx_palloc_small</code>
函数，其代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">ngx_palloc_small</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size, <span class="type">ngx_uint_t</span> align)</span> &#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="type">ngx_pool_t</span>  *p;</span><br><span class="line">    p = pool-&gt;current;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        m = p-&gt;d.last;</span><br><span class="line">        <span class="keyword">if</span> (align) &#123;</span><br><span class="line">            m = ngx_align_ptr(m, NGX_ALIGNMENT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">size_t</span>) (p-&gt;d.end - m) &gt;= size) &#123;</span><br><span class="line">            p-&gt;d.last = m + size;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;d.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p);</span><br><span class="line">    <span class="keyword">return</span> ngx_palloc_block(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在循环中，先获取了内存池头部信息的末尾位置，然后根据用户传入的
<code>align</code> 参数来确定是否调用 <code>ngx_align_ptr</code> 对
<code>d.last</code> 进行字节调整，即调整内存池头部信息的末尾位置。</p>
<p>此后，如果内存池末尾位置减去头部信息末尾位置的大小大于等于
<code>size</code>
参数，即内存池可用空间大小要大于用户需要的大小，则简单的调整
<code>d.last</code> 指针即可，这也是 Nginx 内存池分配内存快的原因。</p>
<p>而如果可用空间小于用户的需求量，那么会通过 <code>d.next</code>
指针进入下一个内存块，由于初始化时该指针为空，则会跳出循环，转而调用
<code>ngx_palloc_block</code> 函数创建一个新的内存池。</p>
<p>我们也可以根据 <code>next</code> 字段的存在大概猜到，Nginx
的小块内存采用的是链表结构。</p>
<h1 id="创建次级内存池">5. 创建次级内存池</h1>
<p>这里我暂且称 <code>ngx_palloc_block</code>
函数所创建的内存池为次级内存池，其代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">ngx_palloc_block</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="type">size_t</span>       psize;</span><br><span class="line">    <span class="type">ngx_pool_t</span>  *p, *new;</span><br><span class="line">    </span><br><span class="line">    psize = (<span class="type">size_t</span>) (pool-&gt;d.end - (u_char *) pool);</span><br><span class="line">    </span><br><span class="line">    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool-&gt;<span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    new = (<span class="type">ngx_pool_t</span> *) m;</span><br><span class="line">    </span><br><span class="line">    new-&gt;d.end = m + psize;</span><br><span class="line">    new-&gt;d.next = <span class="literal">NULL</span>;</span><br><span class="line">    new-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    m += <span class="keyword">sizeof</span>(<span class="type">ngx_pool_data_t</span>);</span><br><span class="line">    m = ngx_align_ptr(m, NGX_ALIGNMENT);</span><br><span class="line">    new-&gt;d.last = m + size;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (p = pool-&gt;current; p-&gt;d.next; p = p-&gt;d.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;d.failed++ &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            pool-&gt;current = p-&gt;d.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p-&gt;d.next = new;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数会先创建一个新的内存池，该内存池的大小与之前创建的内存池大小相同，不同的只是该次级内存池只保留有
<code>ngx_pool_data_t</code>
的相关信息。然后在这个次级内存池中取出用户需要的部分，并调整相关指针、调整边界对齐等。</p>
<p>在最后的循环中，从内存池链表的 <code>current</code>
指针开始，遍历内存池链表，如果某个内存池的 <code>failed</code> 字段比 4
大，则表明该内存池已经分配失败至少 4
次了，说明该内存池的可用空间大小已经不足以分配新的内存空间了，于是就让
<code>current</code> 指向下一个内存池节点。</p>
<p>最后将新创建的次级内存池插入到内存池链表的末尾，返回用户所需的内存空间。</p>
<p>下图为小块内存池链表的相关信息，可见，由于第一个小块内存池的
<code>failed</code> 字段为 5，则其 <code>current</code>
字段则指向了下一个 <code>failed</code> 字段不为 4
的小块内存池，各个小块内存池之间通过 next
指针形成链表形式的数据结构。同时，可以看到，除了第一个内存池之外，后面的所有次级内存池都只有
last、end、next、failed 这四个头部信息：</p>
<p><img data-src="/images/NginxMemoryPool/ngx_struct_3.png" style="zoom:60%"/></p>
<h1 id="创建大块内存">6. 创建大块内存</h1>
<p>首先来看一个关于大块内存信息的数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span>  <span class="title">ngx_pool_large_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span> &#123;</span></span><br><span class="line">    <span class="type">ngx_pool_large_t</span>     *next;</span><br><span class="line">    <span class="type">void</span>                 *alloc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中的 <code>next</code>
指针用于指向下一个大块内存池，和小块内存池一样，其也是一个链表形式的数据结构。另外的
<code>alloc</code> 参数则用于指向在堆中申请的大块内存空间。</p>
<p>如果用户需要的内存空间大于 <code>max</code> 字段，则会调用
<code>ngx_palloc_large</code> 函数来创建大块内存池，其源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">ngx_palloc_large</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">void</span>              *p;</span><br><span class="line">    <span class="type">ngx_uint_t</span>         n;</span><br><span class="line">    <span class="type">ngx_pool_large_t</span>  *large;</span><br><span class="line">    </span><br><span class="line">    p = ngx_alloc(size, pool-&gt;<span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (large = pool-&gt;large; large; large = large-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (large-&gt;alloc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n++ &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    large = ngx_palloc_small(pool, <span class="keyword">sizeof</span>(<span class="type">ngx_pool_large_t</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (large == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ngx_free(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = pool-&gt;large;</span><br><span class="line">    pool-&gt;large = large;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数先调用了 <code>ngx_alloc</code>
函数来申请堆内存，前面阅读源码我们知道，<code>ngx_alloc</code>
函数的底层就是调用的 <code>malloc</code>
函数。然后遍历大块内存池链表，如果有某个大块内存的的 <code>alloc</code>
字段为空，则让该字段指向新申请的堆内存。</p>
<p>为了效率考虑，只寻找 3
次，如果没有找到，则在小块内存池中申请一部分空间用于存放
<code>ngx_pool_large_t</code> 类型，且该结构的 <code>alloc</code>
字段指向新创建的大块堆内存，然后使用头插法放入大块内存的链表中。</p>
<p>大块内存的相关示意图如下所示：</p>
<p><img data-src="/images/NginxMemoryPool/ngx_struct_4.png" style="zoom:60%"/></p>
<h1 id="释放大块内存">7. 释放大块内存</h1>
<p>函数 <code>ngx_pfree</code> 是用来释放大块内存的，其源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ngx_int_t</span> <span class="title function_">ngx_pfree</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_pool_large_t</span>  *l;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == l-&gt;alloc) &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;free: %p&quot;</span>, l-&gt;alloc);</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = <span class="literal">NULL</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> NGX_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> NGX_DECLINED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，该函数会遍历大块内存链表，找寻要释放的大块内存，通过调用
<code>ngx_free</code>，即底层的 <code>free</code>
来释放大块内存空间。释放完成后，将 <code>alloc</code>
字段置为空，用于下次存放重新申请的大块内存。</p>
<p>注意：Nginx
内存池不存在对于小块内存的释放函数，因为从小块内存池中取出区块是通过偏移
<code>d.last</code> 指针来完成的，如果现在在小块内存池中有 3
块连续的内存：1、2、3，现在需要释放内存块 2，很显然，内存块 2
释放后还需要将内存块 1 和内存块 3 拼接在一起，并不高效。</p>
<p>如此设计的原因是因为 Nginx 的应用场景，由于 Nginx 是一个 短链接
的服务器，浏览器(即客户端)发送一个 Request 到达 Nginx
服务器并处理完成，Nginx 会给客户端返回一个 Response 响应，此时 HTTP
服务器就会主动断开 TCP 连接。即使在 HTTP 1.1 中有了 60s 的 Keep Alive
心跳时间(即返回响应后，等待 60s，如果这 60s
内客户端又发来请求，就重置这个时间，否则就主动断开连接)，在超过心跳时间之后，Nginx
就可以调用 <code>ngx_reset_pool</code>
来重置内存池，等待下一个连接的到来。</p>
<p>而如果将该内存池的分配方案应用于一个长连接的服务器，那么内存池模块会持续申请小块内存，而得不到释放，则会一直申请直到服务器资源耗尽。如果需要在长连接的服务器中使用内存池模块，那么可以使用
SGI 的二级空间配置器方案。</p>
<h1 id="内存池重置">8. 内存池重置</h1>
<p>内存池重置操作是通过 <code>ngx_reset_pool</code>
函数来完成的，其源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ngx_reset_pool</span><span class="params">(<span class="type">ngx_pool_t</span> *pool)</span> &#123;</span><br><span class="line">    <span class="type">ngx_pool_t</span>        *p;</span><br><span class="line">    <span class="type">ngx_pool_large_t</span>  *l;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (p = pool; p; p = p-&gt;d.next) &#123;</span><br><span class="line">        p-&gt;d.last = (u_char *) p + <span class="keyword">sizeof</span>(<span class="type">ngx_pool_t</span>);</span><br><span class="line">        p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pool-&gt;current = pool;</span><br><span class="line">    pool-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    pool-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数先遍历大块内存池链表，释放大块内存池。然后遍历小块内存池链表，调整
<code>d.last</code> 指针的偏移，并将 <code>failed</code> 字段重置为
0。</p>
<p>注意，释放小块内存池的循环代码中，存在些许问题，由于只有 pool
指针所指的第一个小块内存池具有全局的数据信息，而后面的次级小块内存池则仅仅包含
<code>last</code>、<code>end</code>、<code>next</code>、<code>failed</code>
这四个信息，但是在该循环中，是按照 <code>ngx_pool_t</code> 的长度来调整
<code>last</code>
指针的，这会使得后面的次级小块内存池在重置后浪费掉部分空间。</p>
<h1 id="清理回调函数">9. 清理回调函数</h1>
<p>现在来考虑如下场景，如果需要申请一个大块内存，该大块内存用于存放一个如下的结构体类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>* str;</span><br><span class="line">	... <span class="comment">// 其它成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中的 <code>str</code> 字段则指向了堆上的一块内存区域，如果现在调用
<code>ngx_pfree</code> 对该大块内存池进行释放，观察
<code>ngx_pfree</code> 的相关源代码可知，其并未处理 <code>str</code>
字段所指向的堆内存，这就会造成内存泄漏。同时由于 C
语言并不存在析构函数来进行内存的清理工作，因此 Nginx
设计了一个回调函数，用于进行内存的清理工作。</p>
<p>位于 <code>ngx_pool_s</code> 结构体中的 <code>cleanup</code>
字段便是做的如此工作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> &#123;</span></span><br><span class="line">    <span class="type">ngx_pool_data_t</span>       d;</span><br><span class="line">    <span class="type">size_t</span>                max;</span><br><span class="line">    <span class="type">ngx_pool_t</span>           *current;</span><br><span class="line">    <span class="type">ngx_chain_t</span>          *chain;</span><br><span class="line">    <span class="type">ngx_pool_large_t</span>     *large;</span><br><span class="line">    <span class="type">ngx_pool_cleanup_t</span>   *cleanup;</span><br><span class="line">    <span class="type">ngx_log_t</span>            *<span class="built_in">log</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*ngx_pool_cleanup_pt)</span><span class="params">(<span class="type">void</span> *data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span>  <span class="title">ngx_pool_cleanup_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span> &#123;</span></span><br><span class="line">    ngx_pool_cleanup_pt   handler;</span><br><span class="line">    <span class="type">void</span>                 *data;</span><br><span class="line">    <span class="type">ngx_pool_cleanup_t</span>   *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中的三个字段的作用如下：</p>
<ul>
<li><code>handler</code>: 存放清理数据的回调函数</li>
<li><code>data</code>: 用于存放回调函数的函数参数</li>
<li><code>next</code>:
表示回调函数也是一个链表形式的数据结构，指向下一个回调函数结构</li>
</ul>
<h1 id="绑定回调函数">10. 绑定回调函数</h1>
<p>函数 <code>ngx_pool_cleanup_add</code>
的作用便是用来绑定回调函数，其源代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ngx_pool_cleanup_t</span>* <span class="title function_">ngx_pool_cleanup_add</span><span class="params">(<span class="type">ngx_pool_t</span> *p, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line">    </span><br><span class="line">    c = ngx_palloc(p, <span class="keyword">sizeof</span>(<span class="type">ngx_pool_cleanup_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (size) &#123;</span><br><span class="line">        c-&gt;data = ngx_palloc(p, size);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    c-&gt;handler = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;next = p-&gt;cleanup;</span><br><span class="line">    </span><br><span class="line">    p-&gt;cleanup = c;</span><br><span class="line">    </span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, p-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;add cleanup: %p&quot;</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，<code>ngx_pool_cleanup_t</code>
也是存放于小块内存池中的，函数最终返回一个
<code>ngx_pool_cleanup_t</code> 的结构，用于用户绑定回调函数。</p>
<p>其示意图如下：</p>
<p><img data-src="/images/NginxMemoryPool/ngx_struct_5.png" style="zoom:60%"/></p>
<h1 id="清理内存池">11. 清理内存池</h1>
<p>函数 <code>ngx_destory_pool</code>
的作用是清理内存池，其相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ngx_destroy_pool</span><span class="params">(<span class="type">ngx_pool_t</span> *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_pool_t</span>          *p, *n;</span><br><span class="line">    <span class="type">ngx_pool_large_t</span>    *l;</span><br><span class="line">    <span class="type">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (c = pool-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler) &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;run cleanup: %p&quot;</span>, c);</span><br><span class="line">            c-&gt;handler(c-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_DEBUG)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * we could allocate the pool-&gt;log from this pool</span></span><br><span class="line"><span class="comment">     * so we cannot use this log while free()ing the pool</span></span><br><span class="line"><span class="comment">     */</span>     </span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;free: %p&quot;</span>, l-&gt;alloc);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;free: %p, unused: %uz&quot;</span>, p, p-&gt;d.end - p-&gt;d.last);</span><br><span class="line">                       </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        ngx_free(p);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，它首先遍历清理用户数据的回调函数链表，调用相应的回调函数来清理内存。然后遍历大块内存池链表以释放大块内存，最后遍历小块内存池链表清理小块内存。</p>
<h1 id="总结">12. 总结</h1>
<p>Nginx 申请内存的流程如下：</p>
<p><img data-src="/images/NginxMemoryPool/flowchart.png" style="zoom:40%"/></p>
]]></content>
      <categories>
        <category>源码剖析</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>内存池</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>STL之空间配置器</title>
    <url>/2022/12/15/STL%E4%B9%8B%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p>STL 空间配置器剖析</p>

</blockquote>
<p>空间配置器 <code>allocator</code>
只是基层内存配置/释放行为的一层薄薄的包装，没有任何效率上的强化。一般而言，C++
内存配置操作和释放操作如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123; ... &#125;;</span><br><span class="line">Foo* pf = <span class="keyword">new</span> Foo;	<span class="comment">// 配置内存，然后构造对象</span></span><br><span class="line"><span class="keyword">delete</span> pf;		<span class="comment">// 将对象析构，然后释放内存</span></span><br></pre></td></tr></table></figure>
<p>其中，new 内含两阶段的操作：</p>
<ol type="1">
<li>调用 ::operator new 配置内存；</li>
<li>调用 Foo::Foo() 构造对象内容。</li>
</ol>
<p>delete 也内含两阶段的操作：</p>
<ol type="1">
<li>调用 Foo::~Foo() 将对象析构；</li>
<li>调用 ::operator delete 释放内存。</li>
</ol>
<p>allocator 将这两阶段的操作分开来。内存配置操作由
<code>alloc::allocate()</code> 负责，内存释放操作由
<code>alloc::deallocate()</code> 负责；对象构造操作由
<code>::construct()</code> 负责，对象析构由 <code>::destroy()</code>
负责。</p>
<p><img data-src="/images/STL_allocator/memory_header.png" style="zoom:70%"/></p>
<p>在 &lt;stl_construct.h&gt; 中，destroy()
有两个版本。第一个版本接受一个指针，将指针所指之物析构掉。而第二个版本接受两个迭代器，将
[first, last)
范围内的所有对象析构掉。但是如果每个对象的析构函数都无关痛痒，而且对象数目很多，则会造成效率上的问题。所以首先利用
<code>value_type()</code> 获得迭代器所指对象的型别，再利用
<code>__type_traits&lt;T&gt;</code>
判断该型别的析构函数是否无关痛痒。</p>
<p>在 &lt;stl_alloc.h&gt;
中，考虑到小型区块所可能造成的内存碎片问题，SGI 设计了双层级配置器：</p>
<ol type="1">
<li>第一级配置器直接使用 malloc() 和 free()</li>
<li>第二级配置器则视情况采用不同的策略。</li>
</ol>
<p>当配置区块超过 128 bytes 时，便调用第一级配置器；当配置区块小于 128
bytes 时，便采用复杂的内存池(memory pool)整理方式。</p>
<p>无论是第一级或第二级配置器，SGI
还为它再包装一个接口如下，使得配置器的接口符合 STL 规格：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>. <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">simple_alloc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> T* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == n ? <span class="number">0</span> : (T*)Alloc::<span class="built_in">allocate</span>(n * <span class="built_in">sizeof</span>(T)); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> T* <span class="title">allocate</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> (T*)Alloc::<span class="built_in">allocate</span>(<span class="built_in">sizeof</span>(T)); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T* p, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">if</span>(<span class="number">0</span> != n) Alloc::<span class="built_in">deallocate</span>(p, n * <span class="built_in">sizeof</span>(T)); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123; Alloc::<span class="built_in">deallocate</span>(p, <span class="built_in">sizeof</span>(T)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/STL_allocator/allocator.png" style="zoom:70%"/></p>
<p>第一级配置器以 malloc()、free()、realloc() 等 C
函数执行实际的内存配置、释放、重配置操作，并实现出类似 C++
<code>new-handler</code> 的机制。SGI 以 malloc() 而非
<code>::operator new</code> 来配置内存，因此，SGI 不能直接使用 C++ 的
<code>set_new_handler()</code> 的操作，必须仿真一个
<code>set_malloc_handler()</code>。一旦内存不足，无法分配，则抛出
<code>bad_alloc</code> 异常，或是利用 exit(1)
直接终止程序，在此之前，会先调用由客户指定的处理例程。</p>
<p>对于第二级配置器，避免了太多小额区块造成内存的碎片，如下图:</p>
<p><img data-src="/images/STL_allocator/cookie.png" style="zoom:70%"/></p>
<p>SGI 第二级配置器的做法是：如果区块过大，超过 128 Bytes
时，就移交给第一级配置器处理。当区块小于 128 Bytes
时，则以内存池管理，也称为【次级配置】。每次配置一大块内存，并维护对应的自由链表，下次若有相同大小的内存需求，则直接从自由链表中取出。同时，如果客户释放小额区块，则由配置器回收到自由链表中。为了方便管理，SGI
第二级配置器会主动将任何小额区块的内存需求量上调至 8
的倍数（例如客户需求 30 Bytes，则上调到 32 Bytes），并维护 16
个链表，各自管理大小分别为
8、16、24、32、40、48、56、64、72、80、88、96、104、112、120、128 bytes
的小额区块。自由链表节点结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">obj</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">obj</span>* free_list_link;</span><br><span class="line">    <span class="type">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/STL_allocator/freelist.png" style="zoom:70%"/></p>
<p>而结点正是因为 union 的缘故，所以从第一个字段出发，obj
被视为指向另一个结点的指针，从第二个字段出发，obj
被视为指向实际区块的指针。这样的方式节省了内存，省下了额外负担。</p>
<p><img data-src="/images/STL_allocator/freelist2.png" style="zoom:50%"/></p>
<p>第二级配置器通过 allocate() 分配内存，通过 deallocate()
释放内存。如果申请内存时，自由链表中没有可用区块时，就调用 refill()
为自由链表重新填充空间。新的空间取自内存池，由
<code>chunk_alloc()</code> 来完成，它通过
<code>end_free - start_free</code> 来判断内存池的水量。</p>
<p>如果水量充足，就直接调出 20 个区块返回给自由链表。</p>
<p><img data-src="/images/STL_allocator/memory_pool.png" style="zoom:50%"/></p>
<p>如果水量不足以提供 20
个区块，但是还足够提供一个以上的区块，就取出这个不足 20
个区块的空间出去，同时，将 pass-by-reference 的 nobjs
参数修改为实际能够供应的区块数。</p>
<p><img data-src="/images/STL_allocator/memory_pool2.png" style="zoom:50%"/></p>
<p>如果内存池连一个区块空间都无法供应，此时便需要利用 malloc() 从 heap
中配置内存，为内存池注入新的内存以供需求。先将内存池剩余的零头配置给合适的自由链表，然后向堆空间申请新的内存，新注入的水量为需求量的
2
倍，再加上一个随着配置次数增加而愈来愈大的附加量。最后将将第一块返回给用户，剩下的
19 块依附在自由链表上，余下的 20+n 个留在内存池中。</p>
<p><img data-src="/images/STL_allocator/memory_pool3.png" style="zoom:50%"/></p>
<p>如果整个堆空间的内存已经不够申请了，malloc() 行动失败，那么
chunk_alloc()
就找寻有无尚未使用之区块，且区块足够大的自由链表，如果找到了就取出来；如果没找到就调用第一级空间配置器，利用其
<code>out-of-memory</code>
处理机制，或许有机会释放其他内存拿来使用。如果可以就成功，否则发出
<code>bad_alloc</code> 异常。</p>
<p><img data-src="/images/STL_allocator/memory_pool4.png" style="zoom:50%"/></p>
]]></content>
      <categories>
        <category>源码剖析</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能分布式网络服务器框架</title>
    <url>/2023/04/21/%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p>使用 C/C++ 开发的一款高性能的后端分布式服务器网络框架。</p>

</blockquote>
<p>该项目具有如下要点：</p>
<ul>
<li>使用 C++11 重写并简化 <a
href="https://github.com/chenshuo/muduo">muduo</a> 网络库；</li>
<li>仿写了 <a href="https://github.com/google/tcmalloc">tcmalloc</a>
的高并发内存池；</li>
<li>加入了 <a href="https://github.com/sylar-yin/sylar">sylar</a>
的日志模块并将其改进为异步日志；</li>
<li>使用到了 <a
href="https://github.com/protocolbuffers/protobuf">protobuf</a> 和 <a
href="https://zookeeper.apache.org/">Zookeeper</a>
来作为分布式协调服务；</li>
</ul>
<div class="text-center">
<a class="btn" href="https://github.com/Kohirus/Apollo" title="GitHub"><i class="fab fa-github fa-fw fa-lg"></i>Github-Apollo</a>
</div>
<h1 id="项目部署">项目部署</h1>
<h2 id="开发环境">1. 开发环境</h2>
<ul>
<li>OS：Ubuntu 22.04 LTS</li>
<li>构建工具：CMake 3.16.3</li>
<li>编译器：GCC 9.4.0</li>
<li>调试器：GDB 9.2</li>
<li>第三方模块：
<ul>
<li><a href="https://github.com/nlohmann/json">json.cpp</a>：3.11.2</li>
<li>protobuf：3.17.0</li>
<li>ZooKeeper：3.4.10</li>
</ul></li>
</ul>
<h2 id="部署方法">2. 部署方法</h2>
<p>可以运行 <code>autobuild.sh</code> 直接进行编译。或者创建
<code>build</code> 目录并进入，然后输入如下命令进行编译：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>如果不需要采用 tcmallloc 内存池模块，而是采用系统原生的
malloc/free，那么更改项目根路径下的 CMakeLists.txt
文件中的如下内容即可：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># option(TCMALLOC &quot;use tcmalloc&quot; ON) </span></span><br><span class="line"><span class="keyword">option</span>(TCMALLOC <span class="string">&quot;use tcmalloc&quot;</span> <span class="keyword">OFF</span>)</span><br></pre></td></tr></table></figure>
<p>或者进入 build 目录使用如下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cmake .. -DTCMALLOC=ON</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>如果需要采用 poll 而非 epoll 来作为 I/O 复用模型，那么修改根路径下的
CMakeLists.txt 文件中的如下内容即可：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># option(APLUSEPOLL &quot;use poll&quot; OFF)</span></span><br><span class="line"><span class="keyword">option</span>(APLUSEPOLL <span class="string">&quot;use poll&quot;</span> <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure>
<p>或者进入 build 目录使用如下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cmake .. -DAPLUSEPOLL=ON</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<div class="note info"><p>默认情况下，运行 autobuild.sh 文件时会启用 tcmalloc 内存池，同时使用
epoll 来作为 I/O 复用模型。</p>
</div>
<div class="note danger"><p>注意，使用该框架时需要在可执行文件的所在路径下添加
<code>config.json</code>
配置文件，以配置日志、节点服务器、发现服务器等信息。</p>
</div>
<h2 id="配置文件">3. 配置文件</h2>
<p>配置文件位于可执行文件的所在路径下，且名为
<code>config.json</code>，如下是其示例配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;log&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;root&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="string">&quot;INFO&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;formatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%d&#123;%Y-%m-%d %H:%M:%S&#125;%T%t%T%c%T[%p]%T%f:%l%T%m%n&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;appenders&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;file&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./log/root.txt&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;async&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stdout&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rpc&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DEBUG&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;formatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%d&#123;%Y-%m-%d %H:%M:%S&#125;%T%t%T%c%T[%p]%T%f:%l%T%m%n&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;appenders&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;file&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./log/rpc.txt&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;async&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;rpc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">8000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;thread&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;zookeeper&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">5000</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中，配置信息主要由如下三部分组成：</p>
<ul>
<li>log：日志配置信息
<ul>
<li>name：日志名称</li>
<li>level：日志等级，支持DEBUG、INFO、WARN、ERROR、FATAL</li>
<li>formatter：日志格式</li>
<li>appenders：日志输出目的地，可以配置多个
<ul>
<li>type：日志类型，支持file(文件)、stdout(标准输出)</li>
<li>file：文件名称</li>
<li>async：是否为异步日志(目前尚未支持)</li>
</ul></li>
</ul></li>
<li>rpc：RPC节点配置信息
<ul>
<li>ip：IP地址</li>
<li>port：端口号</li>
<li>thread：线程数目</li>
</ul></li>
<li>zookeeper：发现服务器的配置信息
<ul>
<li>ip：IP地址</li>
<li>port：端口号</li>
</ul></li>
</ul>
<p>对于日志格式而言，所支持的字段如下：</p>
<table>
<thead>
<tr class="header">
<th>格式化字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>%m</td>
<td>消息内容</td>
</tr>
<tr class="even">
<td>%p</td>
<td>日志等级</td>
</tr>
<tr class="odd">
<td>%c</td>
<td>日志名称</td>
</tr>
<tr class="even">
<td>%t</td>
<td>线程ID</td>
</tr>
<tr class="odd">
<td>%n</td>
<td>换行符</td>
</tr>
<tr class="even">
<td>%d</td>
<td>日志时间</td>
</tr>
<tr class="odd">
<td>%f</td>
<td>文件名</td>
</tr>
<tr class="even">
<td>%l</td>
<td>行号</td>
</tr>
<tr class="odd">
<td>%T</td>
<td>制表符</td>
</tr>
<tr class="even">
<td>%N</td>
<td>线程名称</td>
</tr>
</tbody>
</table>
<div class="note info"><p>时间的格式化字符见 <code>strftime</code> 函数。</p>
</div>
<h2 id="如何使用">4. 如何使用</h2>
<p>首先需要通信双方约定消息格式，示例文件如下，其中
<code>option cc_generic_services = true</code> 必须开启：</p>
<figure class="highlight proto"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span> &#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> errmsg = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span> &#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span> &#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserServiceRpc</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Login(LoginRequest) <span class="keyword">returns</span>(LoginResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过如下命令在当前路径下生成相应的头文件和源文件，该头文件中会包含两个类：<code>UserServiceRpc</code>
和 <code>UserServiceRpc_Stub</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">proto xxx.proto --cpp_out=./</span><br></pre></td></tr></table></figure>
<p>对于服务提供方而言，需要继承 <code>UserServiceRpc</code>
类，并重写相应的方法，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> : <span class="keyword">public</span> UserServiceRpc &#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Login</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; pwd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现业务方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重新基类方法</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Login</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> ::fixbug::LoginRequest*             request,</span></span></span><br><span class="line"><span class="params"><span class="function">    ::fixbug::LoginResponse*                  response,</span></span></span><br><span class="line"><span class="params"><span class="function">    ::google::protobuf::Closure*              done)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过request参数获取请求方的函数参数</span></span><br><span class="line">    std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">    std::string pwd  = request-&gt;<span class="built_in">pwd</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行本地业务</span></span><br><span class="line">    <span class="type">bool</span> res = <span class="built_in">Login</span>(name, pwd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将响应结果写入response参数</span></span><br><span class="line">    fixbug::ResultCode* code = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">    code-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">    code-&gt;<span class="built_in">set_errmsg</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    response-&gt;<span class="built_in">set_success</span>(res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行回调操作</span></span><br><span class="line">    done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 把UserService对象发布到RPC节点上</span></span><br><span class="line">  RpcProvider provider;</span><br><span class="line">  provider.<span class="built_in">notifyService</span>(<span class="keyword">new</span> <span class="built_in">UserService</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动一个rpc服务发布节点</span></span><br><span class="line">  provider.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于服务请求方而言，实例化一个 <code>UserServiceRpc_Stub</code>
对象，然后将函数参数放入到 request 对象中，然后通过
<code>UserService_Stub</code> 对象执行远程调用即可，最终通过
RpcControllerImpl 得知远程调用是否成功，如果成功则通过 response
对象取出服务请求的结果即可，示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">fixbug::UserServiceRpc_Stub <span class="title">stub</span><span class="params">(<span class="keyword">new</span> apollo::RpcChannelImpl)</span></span>;</span><br><span class="line">  fixbug::LoginRequest        request;</span><br><span class="line">  request.<span class="built_in">set_name</span>(<span class="string">&quot;zhang san&quot;</span>);</span><br><span class="line">  request.<span class="built_in">set_pwd</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">  fixbug::LoginResponse response;</span><br><span class="line">  <span class="comment">// 发起RPC同步调用</span></span><br><span class="line">  apollo::RpcControllerImpl controller;</span><br><span class="line">  stub.<span class="built_in">Login</span>(&amp;controller, &amp;request, &amp;response, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (controller.<span class="built_in">Failed</span>()) &#123;</span><br><span class="line">      std::cout &lt;&lt; controller.<span class="built_in">ErrorText</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// RPC调用完成 读取结果</span></span><br><span class="line">      <span class="keyword">if</span> (response.<span class="built_in">result</span>().<span class="built_in">errcode</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">          std::cout &lt;&lt; <span class="string">&quot;rpc login response: &quot;</span> &lt;&lt; response.<span class="built_in">success</span>() &lt;&lt; std::endl;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          std::cout &lt;&lt; <span class="string">&quot;failed to rpc login: &quot;</span> &lt;&lt; response.<span class="built_in">result</span>().<span class="built_in">errmsg</span>() &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="内存池模块">内存池模块</h1>
<p>该项目所使用的内存池原型是 Google 的开源项目 tcmalloc，其全称为
Thread-Caching Malloc，即线程缓存的
malloc，实现了高效的多线程内存管理，用于替换系统的内存分配相关函数，即
malloc 和 free。</p>
<p>内存池主要解决的就是效率问题，它能够避免让程序频繁的向系统申请和释放内存。其次，内存池作为系统的内存分配器，还需要尝试解决内存碎片的问题，内存碎片分为如下两种：</p>
<ul>
<li><strong>外部碎片</strong>：指的是空闲的小块内存区域，由于这些内存空间不连续，以至于合计的内存足够，但是不能满足一些内存分配的需求。</li>
<li><strong>内部碎片</strong>：指的是由于一些对齐的需求，导致分配出去的空间中一些内存无法被充分利用。</li>
</ul>
<div class="note info"><p>内存池尝试解决的是外部碎片的问题，同时也尽可能的减少内部碎片的产生。</p>
</div>
<p>该内存池的整体架构如下图所示：</p>
<p><img data-src="/images/apollo/memory_pool_structure.png" width="50%" height="50%"/></p>
<p>其主要由以下三个部分组成：</p>
<ul>
<li><code>Thread Cache</code>: 线程缓存是每个线程独有的，用于小于等于
256KB 的内存分配，每个线程独享一个 ThreaCache了。</li>
<li><code>Central Cache</code>: 中心缓存是所有线程共享的，当 ThreadCache
需要内存时会按需从 CentralCache 中获取内存，而当 ThreadCache
中的内存满足一定条件时，CentralCache 也会在合适的时机对其进行回收。</li>
<li><code>Page Cache</code>:
页缓存中存储的内存是以页为单位进行存储及分配的，当 CentralCache
需要内存时，PageCache 会分配出一定数量的页给 CentralCache，而当
CentralCache 中的内存满足一定条件时，PageCache
也会在合适的时机对其进行回收，并将回收的内存尽可能的进行合并，组成更大的连续内存块，缓解内存碎片的问题。</li>
</ul>
<p>上述三个部分的主要作用如下：</p>
<ul>
<li>Thread Cache: 主要解决锁竞争的问题；</li>
<li>Central Cache: 主要负责居中调度的问题；</li>
<li>Page Cache: 主要负责提供以页为单位的大块内存；</li>
</ul>
<h2 id="threadcache">1.ThreadCache</h2>
<p>Thread Cache 的结构如下图所示：</p>
<p><img data-src="/images/apollo/thread_cache.png" width="55%" height="55%"/></p>
<p>通过使用<strong>字节对齐</strong>的方法来减少哈希桶的数目，并且进一步增加内存利用率，在设计时，让不同的范围的字节数按照不同的对齐数进行对齐，具体的对齐方式如下：</p>
<table>
<thead>
<tr class="header">
<th>字节数</th>
<th>对齐数</th>
<th>哈希桶下标</th>
<th>自由链表数目</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[1, 128]</td>
<td>8</td>
<td>[0, 16)</td>
<td>16</td>
</tr>
<tr class="even">
<td>[129, 1024]</td>
<td>16</td>
<td>[16, 72)</td>
<td>56</td>
</tr>
<tr class="odd">
<td>[1025, 8*1024]</td>
<td>128</td>
<td>[72, 128)</td>
<td>56</td>
</tr>
<tr class="even">
<td>[8*1024+1, 64*1024]</td>
<td>1024</td>
<td>[128, 184)</td>
<td>56</td>
</tr>
<tr class="odd">
<td>[64*1024+1, 256*1024]</td>
<td>8*1024</td>
<td>[184, 208)</td>
<td>24</td>
</tr>
</tbody>
</table>
<p>为了实现每个线程无锁访问属于自己的 Thread
Cache，就需要用到<strong>线程局部存储</strong>(Thread Local Storage,
TLS)，使用该存储方法的变量在它所在的线程是全局可访问的，但是不能被其它线程访问到，这样就保证了数据的线程独立性。</p>
<p>当某个线程申请的对象不用了，可以将其释放给 Thread Cache，然后 Thread
Cache 将该对象插入到哈希桶的自由链表当中即可。</p>
<p>但是随着线程不断地释放，对应自由链表中的长度也会越来越长，这些内存堆积在一个
Thread Cache 中就是一种浪费，此时应该将这些内存还给 Central
Cache，这样一来，这些内存对于其它线程来说就是可申请的，因此当 Thread
Cache 中某个桶当中的自由链表太长时，可以将其释放给 Central Cache。</p>
<h2 id="centralcache">2. CentralCache</h2>
<p>当线程申请某一大小的内存时，如果 Thread Cache
中对应的自由链表不为空，那么直接取出一个内存块返回即可，但如果此时该自由链表为空，那么这时
Thread Cache 就需要向 Central Cache 申请内存了。</p>
<p>Central Cache 的结构与 Thread Cache
是一样的，都是哈希桶结构，并且所遵循的对齐规则也一致。这样做的好处是当
Thread Cache 的某个桶中没有内存时，就可以直接到 Central Cache
中相对应的哈希桶中取内存。</p>
<p>Central Cache 与 Thread Cache 不同之处有两点：</p>
<ol type="1">
<li>Central Cache 是所有线程共享的，而 Thread Cache 是线程独享的；</li>
<li>Central Cache 的哈希桶中挂载的是 Span，而 Thread Cache
的哈希桶中挂载的是切好的内存块；</li>
</ol>
<p>其结构如下所示：</p>
<p><img data-src="/images/apollo/central_cache.png" width="65%" height="65%"/></p>
<p>由于 Central Cache 是所有线程共享的，多个 Thread Cache
可能在同一时刻向 Central Cache
申请内存块，因此为了保证线程安全，需要加锁控制。此外，由于只有多个线程同时访问
Central Cache
的同一个桶时才会存在锁竞争，因此无需用锁来锁住所有哈希桶，只需锁住当前所访问的哈希桶即可。</p>
<p>当 Thread Cache 向 Central Cache 申请内存时，如果给的太少，那么
Thread Cache 在短时间用完了又会再来申请；但是如果给的太多，那么 Thread
Cache
可能用不完而浪费大量的空间。为此，此处采用<strong>慢反馈调节算法</strong>，当
Thread Cache 向 Central Cache
申请内存时，如果申请的是较小的对象，那么可以多给一点，但如果申请的是较大的对象，就可以少给一点。</p>
<p>当 Thread Cache 中的某个自由链表太长时，会将自由链表中的对象归还给
Central Cache 中的 Span。但是需要注意的是，归还给 Central Cache
的这些对象不一定都属于同一个 Span 的，且 Central Cache
中的每个哈希桶中都可能不止一个
Span，因此归还时不仅需要知道该对象属于哪一个桶，还需要知道它属于这个桶中的哪一个
Span。为了建立页号和 Span
之间的映射，需要使用一种哈希表结构进行管理，一种方式是采用 C++ 中的
unordered_map，另一种方式是采用<strong>基数树</strong>数据结构。</p>
<h2 id="pagecache">3. PageCache</h2>
<p>Page Cache 的结构与 Central Cache 一样，都是哈希桶的结构，并且 Page
Cache 的每个哈希桶中都挂的是一个个的 Span，这些 Span
也是按照双向链表的结构连接起来的。</p>
<p>但是，Page Cache 的映射规则与 Central Cache 和 Thread Cache
不同，其采用的是<strong>直接定址法</strong>，比如 1 号桶挂的都是 1 页的
Span，2 号桶挂的都是 2 页的 Span，以此类推。</p>
<p>其次，Central Cache 每个桶中的 Span
都被切为了一个个对应大小的对象，以供 Thread Cache 申请。而 Page Cache
服务的是 Central Cache，当 Central Cache 中没有 Span 时，向 Page Cache
申请的是某一固定页数的 Span。而如果切分这个申请到的 Span 就应该由
Central Cache 自己来决定。</p>
<p>其结构如下图所示：</p>
<p><img data-src="/images/apollo/page_cache.png" width="65%" height="65%"/></p>
<p>当每个线程的 Thread Cache 没有内存时都会向 Central Cache
申请，此时多个线程的 Thread Cache 如果访问的不是 Central Cache
的同一个桶，那么这些线程是可以同时进行访问的。这时 Central Cache
的多个桶就可能同时向 Page Cache 申请内存，所以 Page Cache
也是存在线程安全问题的，因此在访问 Page Cache 时也必须要加锁。</p>
<p>但是此处的 Page Cache 不能使用桶锁，因为当 Central Cache 向 Page
Cache 申请内存时，Page Cache 可能会将其他桶中大页的 Span 切小后再给
Central Cache。此外，当 Central Cache 将某个 Span 归还给 Page Cache
时，Page Cache 也会尝试将该 Span 与其它桶当中的 Span 进行合并。</p>
<p>也就是说，在访问 Page Cache
时，可能同时需要访问多个哈希桶，如果使用桶锁则可能造成大量频繁的加锁和解锁，导致程序的效率底下。因此在访问
Page Cache 时没有使用桶锁，而是用一个大锁将整个 Page Cache 锁住。</p>
<p>如果 Central Cache 中有某个 Span 的 <code>useCnt_</code> 减到 0
了，那么 Central Cache 就需要将这个 Span 归还给 Page Cache
了。为了缓解内存碎片问题，Page Cache 还需要尝试将还回来的 Span
与其它空闲的 Span 进行合并。</p>
<h2 id="基数树">4. 基数树</h2>
<p>由于在 PageCache 中最初建立页号与 Span 之间的映射关系时，采用的是
unordered_map 数据结构，但是通过性能测试发现，内存池的性能并未优于原生的
malloc/free 接口，因此通过 Visual Studio 的性能分析工具发现性能瓶颈位于
unordered_map 处。</p>
<p>这主要是因为 unordered_map
不是线程安全的，在多线程环境下需要加锁，而大量的加锁则会导致资源的消耗和性能的下降，因此在映射页号与
Span 之间的关系时，采用基数树（Radix Tree）数据结构来进行优化。</p>
<p>当采用如下图所示的单层基数树时，在 32 位平台下，以一页大小为 8K(<span
class="math inline">\(2^{13}\)</span>) 为例，此时页的数目就是 <span
class="math inline">\(2^{32}\div
2^{13}=2^{19}\)</span>，因此存储页号最多需要 19 个比特位，同时由于 32
位平台下的指针大小为 4 字节，因此该数组的大小就是 <span
class="math inline">\(2^{19}\times
4=2^{21}=2M\)</span>，内存消耗不大，是可行的。但是如果是在 64
位平台下，此时该数组的大小就是 <span class="math inline">\(2^{51}\times
8=2^{54}=2^{24}G\)</span>，这显然是不可行的：</p>
<p><img data-src="/images/apollo/radix_tree_1.png" width="40%" height="40%"/></p>
<p>如下图所示，为二层基数树，同样在 32 位平台下，以一页的大小为 8K
为例来说明，此时存储页号最多需要 19 个比特位。而二层基数树实际上就是把这
19 个比特位分为两次进行映射。例如，前 5
个比特位在基数树的第一层进行映射，映射后得到对应的第二层，然后用剩下的比特位在基数树的第二层进行映射，映射后最终得到该页号所对应的
Span 指针。</p>
<p><img data-src="/images/apollo/radix_tree_2.png"/></p>
<p>在二层基数树中，第一层的数组占用 <span
class="math inline">\(2^5\times 4=2^7\)</span> Bytes
空间，第二层的数组最多占用 <span class="math inline">\(2^5\times
2^{14}\times
4=2^{21}=2M\)</span>。二层基数树相比与一层基数树的好处就是，一层基数树必须一开始就把
2M
的数组开辟出来，而二层基数树一开始只需要将第一层的数组开辟出来，当需要进行某一页号映射时再开辟对应的第二层的数组就行了。</p>
<p>在 32 位平台下，一层基数树和二层基数树都是适用的，但是在 64
位平台下，就需要使用下图所示的三层基数树了。三层基数树类似于二层基数树，实际上就是把存储页号的若干比特分为三次进行映射，而且只有当需要建立某一页号的映射关系时，才会开辟对应的数组空间，在一定程度上节约了内存空间：</p>
<p><img data-src="/images/apollo/radix_tree_3.png"/></p>
<h2 id="性能测试">5. 性能测试</h2>
<p>单线程下内存池性能测试结果如下表所示，其中 <code>alloc/dealloc</code>
表示使用内存池来进行内存的申请和分配，而 <code>malloc/free</code>
表示使用系统原生的 API 来进行内存的申请和分配，表格中的单位为秒：</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 17%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th>申请次数</th>
<th>malloc</th>
<th>free</th>
<th>malloc&amp;free</th>
<th>alloc</th>
<th>dealloc</th>
<th>alloc&amp;dealloc</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>100</td>
<td>0.000108</td>
<td>2.2e-05</td>
<td>0.00013</td>
<td>0.000366</td>
<td>6e-05</td>
<td>0.000426</td>
</tr>
<tr class="even">
<td>500</td>
<td>0.000344</td>
<td>0.000111</td>
<td>0.000455</td>
<td>0.002713</td>
<td>0.000235</td>
<td>0.002948</td>
</tr>
<tr class="odd">
<td>1000</td>
<td>0.000935</td>
<td>0.000409</td>
<td>0.001344</td>
<td>0.007691</td>
<td>0.000355</td>
<td>0.008046</td>
</tr>
<tr class="even">
<td>5000</td>
<td>0.021884</td>
<td>0.004798</td>
<td>0.026682</td>
<td>0.007954</td>
<td>0.00218</td>
<td>0.010134</td>
</tr>
<tr class="odd">
<td>10000</td>
<td>0.06108</td>
<td>0.011623</td>
<td>0.071731</td>
<td>0.020134</td>
<td>0.003578</td>
<td>0.023712</td>
</tr>
<tr class="even">
<td>20000</td>
<td>0.120307</td>
<td>0.028152</td>
<td>0.148459</td>
<td>0.024508</td>
<td>0.006907</td>
<td>0.031415</td>
</tr>
<tr class="odd">
<td>30000</td>
<td>0.199733</td>
<td>0.043747</td>
<td>0.24348</td>
<td>0.03611</td>
<td>0.011694</td>
<td>0.047804</td>
</tr>
</tbody>
</table>
<p>单线程性能测试结果的折线图如下所示：</p>
<p><img data-src="/images/apollo/performance_test_st.png"/></p>
<p>多线程下的性能测试结果如下表所示，每个线程都需申请/释放内存 10000
次：</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 17%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th>线程数目</th>
<th>malloc</th>
<th>free</th>
<th>malloc&amp;free</th>
<th>alloc</th>
<th>dealloc</th>
<th>alloc&amp;dealloc</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0.06108</td>
<td>0.011623</td>
<td>0.071731</td>
<td>0.06108</td>
<td>0.011623</td>
<td>0.071731</td>
</tr>
<tr class="even">
<td>2</td>
<td>0.2204</td>
<td>0.076146</td>
<td>0.296546</td>
<td>0.059878</td>
<td>0.015874</td>
<td>0.075752</td>
</tr>
<tr class="odd">
<td>3</td>
<td>0.613199</td>
<td>0.194174</td>
<td>0.807373</td>
<td>0.156596</td>
<td>0.03168</td>
<td>0.188276</td>
</tr>
<tr class="even">
<td>4</td>
<td>0.492761</td>
<td>0.060352</td>
<td>0.553113</td>
<td>0.492761</td>
<td>0.060352</td>
<td>0.553113</td>
</tr>
<tr class="odd">
<td>5</td>
<td>2.65943</td>
<td>0.416495</td>
<td>3.07592</td>
<td>0.680774</td>
<td>0.092576</td>
<td>0.77335</td>
</tr>
<tr class="even">
<td>6</td>
<td>4.16152</td>
<td>0.528937</td>
<td>4.69046</td>
<td>0.815121</td>
<td>0.123539</td>
<td>0.93866</td>
</tr>
<tr class="odd">
<td>7</td>
<td>5.43473</td>
<td>0.805814</td>
<td>6.24054</td>
<td>1.18223</td>
<td>0.166473</td>
<td>1.34871</td>
</tr>
</tbody>
</table>
<p>多线程性能测试结果的折线图如下所示：</p>
<p><img data-src="/images/apollo/performance_test_mt.png"/></p>
<p>综合对比上面的测试数据，可以看出，当申请的内存次数较小时，使用系统原生的
API 更为合适，而如果申请次数过多时，内存池的优势就逐渐体现出来了。</p>
<h1 id="网络通信模块">网络通信模块</h1>
<p>网络通信模块采用的是 muduo 网络库，本项目通过使用 C++11 简化 muduo
网络库，同时去除了 Boost 库的依赖以及一些冗余的组件，提取出 muduo
库中的核心思想，即 One Loop Per Thread。</p>
<h2 id="reactor">1. Reactor</h2>
<p>该网络库采用的是 Reactor
事件处理模式。在《Linux高性能服务器编程》中，对于 Reactor
模型的描述如下：<strong>主线程（即 I/O
处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程（即逻辑单元）。此外，主线程不做任何其他实质性的工作。读写数据、接受新的连接，以及处理客户请求均在工作线程中完成</strong>。Reactor
模式的时序图如下：</p>
<p><img data-src="/images/apollo/reactor_model.png" width="80%" height="80%"/></p>
<p>而 muduo 网络库的时序图则如下图所示：</p>
<p><img data-src="/images/apollo/muduo_timing_diagram.png" width="85%" height="85%"></p>
<p>其次，在《Linux高性能服务器编程》一书中还提到了<strong>半同步/半异步</strong>的并发模式，注意，此处的“异步”与
I/O 模型中的异步并不相同，I/O
模型中的“同步”和“异步”的区分是内核应用程序通知的是何种事件（就绪事件还是完成事件），以及由谁来完成
I/O
读写（是应用程序还是内核）。而在并发模式中，“同步”指的是完全按照代码序列的顺序执行，“异步”则指的是程序的执行需要由系统事件来驱动，比如常见的系统终端、信号等。</p>
<p>而 muduo
库所采用的便是高效的半同步/半异步模式，其结构如下图所示：</p>
<p><img data-src="/images/apollo/structure.png" width="75%" height="75%"/></p>
<p>上图中，主线程只管理监听 socket，连接 socket
由工作线程来管理。当有新的连接到来时，主线程就接受并将新返回的连接
socket 派发给某个工作线程，此后在该 socket 上的任何 I/O
操作都由被选中的工作线程来处理，直到客户关闭连接。主线程向工作线程派发
socket
的最简单的方式，是往它和工作线程之间的管道写数据。工作线程检测到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。如果是，则把新
socket 上的读写事件注册到自己的 epoll
内核事件表中。上图中的每个线程都维持自己的事件循环，它们各自独立的监听不同的事件。因此，在这种高效的半同步/半异步模式中，每个线程都工作在异步模式，所以它并非严格意义上的半同步/半异步模式。</p>
<p>通常情况下，Reactor 模式的实现有如三几种方式：</p>
<ul>
<li>Single Reactor - Single Thread</li>
<li>Single Reactor - Multi Threads</li>
<li>Multi Reactors - Multi Threads</li>
</ul>
<p>对于 “Single Reactor - Single Thread” 模型而言，其通常只有一个 epoll
对象，所有的接收客户端连接、客户端读取、客户端写入操作都包含在一个线程内，如下图所示：</p>
<p><img data-src="/images/apollo/sr_st_model.png" width="65%" height="65%"/></p>
<p>但在目前的单线程 Reactor 模式中，不仅 I/O 操作在该 Reactor
线程上，连非 I/O 的业务操作也在该线程上进行处理了，这可能会大大延迟 I/O
请求的响应。为了提高服务器的性能，我们需要将非 I/O 的业务逻辑操作从
Reactor 线程中移动到工作线程中进行处理。</p>
<p>为此，可以通过使用线程池模型的方法来改进，即 “Single Reactor - Multi
Threads”
模型，其结构如下图所示。将读写的业务逻辑交给具体的线程池来实现，这样可以显示
reactor 线程对 IO 的响应，以此提升系统性能。</p>
<p><img data-src="/images/apollo/sr_mt_model.png" width="65%" height="65%"/></p>
<p>尽管现在已经将所有的非 I/O 操作交给了线程池来处理，但是所有的 I/O
操作依然由 Reactor
单线程执行，在高负载、高并发或大数据量的应用场景，依然较容易成为瓶颈。</p>
<p>为了继续提升服务器的性能，进而改造出了如下图所示的 “Multi Reactors -
Multi Threads” 模型：</p>
<p><img data-src="/images/apollo/mr_mt_model.png" width="75%" height="75%"/></p>
<p>在这种模型中，主要分为两个部分：mainReactor、subReactors。
mainReactor
主要负责接收客户端的连接，然后将建立的客户端连接通过负载均衡的方式分发给
subReactors，subReactors 则负责具体的每个连接的读写，而对于非 IO
的操作，依然交给工作线程池去做，对逻辑进行解耦。</p>
<p>而在 muduo 网络库中，便采用的是此种模型，每一个 Reactor 都是一个
EventLoop 对象，而每一个 EventLoop 则和一个线程唯一绑定，这也就是 One
Loop Per Thread 的含义所在。其中，MainLoop
只负责新连接的建立，连接建立成功后则将其打包为 TcpConnection 对象分发给
SubLoop，在 muduo 网络库中，采用的是 “轮询算法” 来选择处理客户端连接的
SubLoop。之后，这个已建立连接的任何操作都交付给该 SubLoop 来处理。</p>
<p>通常在服务器模型中，我们可以使用 “任务队列” 的方式向 SubLoop
派发任务，即 MainLoop 将需要执行的任务放到任务队列中，而 SubLoop
则从任务队列中取出任务并执行，当任务队列中没有任务时，SubLoop
则进行休眠直到任务队列中有任务出现。但是在 muduo
网络库却中并未采用这一方式，而是采用了另一个更加高效的方式，以便让
MainLoop 唤醒 SubLoop 处理任务。</p>
<p>在上述的 “半同步/半异步” 模式中，我们提到了，主线程向工作线程派发
socket
最简单的方式，就是往它和工作线程之间的管道写数据。为此，我们可以在
MainLoop 和 SubLoop 之间建立管道来进行通信，当有任务需要执行时，MainLoop
通过管道将数据发送给 SubLoop，SubLoop 则通过 epoll
模型监听到了管道上所发生的可读（EPOLLIN）事件，然后调用相应的读事件回调函数来处理任务。</p>
<p>但是在 muduo 库中，则采用了更为高效的 <code>eventfd()</code>
接口，它通过创建一个文件描述符用于事件通知，自 Linux 2.6.22
以后开始支持。</p>
<div class="note info"><p>eventfd 在信号通知的场景下，相对比 pipe
有非常大的资源和性能优势，它们的对比如下：</p>
<ol type="1">
<li><p>首先在于它们所打开的文件数量的差异，由于 pipe 是半双工的传统 IPC
实现方式，所以两个线程通信需要两个 pipe 文件描述符，而用 eventfd
则只需要打开一个文件描述符。总所周知，文件描述符是系统中非常宝贵的资源，Linux
的默认值只有 1024 个，其次，pipe
只能在两个进程/线程间使用，面向连接，使用之前就需要创建好两个 pipe ,而
eventfd 是广播式的通知，可以多对多。</p></li>
<li><p>另一方面则是内存使用的差别，eventfd
是一个计数器，内核维护的成本非常低，大概是自旋锁+唤醒队列的大小，8
个字节的传输成本也微乎其微，而 pipe
则完全不同，一来一回的数据在用户空间和内核空间有多达 4
次的复制，而且最糟糕的是，内核要为每个 pipe 分配最少 4K
的虚拟内存页，哪怕传送的数据长度为 0。</p></li>
</ol>
</div>
<h2 id="io-multiplexing">2. I/O multiplexing</h2>
<p>在 Linux 系统下，常见的 I/O 复用机制有三种：select、poll 和
epoll。</p>
<p>其中，select 模型的缺点如下：</p>
<ol type="1">
<li>单个进程能够监视的文件描述符的数量存在最大限制，通常是
1024，当然可以更改数量，但由于 select
采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差；</li>
<li>内核和用户空间的内存拷贝问题，select
需要复制大量的句柄数据结构，会产生巨大的开销；</li>
<li>select
返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件；</li>
<li>select
的触发方式是水平触发，应用程序如果没有对一个已经就绪的文件描述符进行相应的
I/O 操作，那么之后每次 select 调用还是会将这些文件描述符通知进程；</li>
</ol>
<p>相比于 select 模型，poll
则使用链表来保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依然存在。</p>
<p>而 epoll 的实现机制与 select/poll 机制完全不同，它们的缺点在 epoll
模型上不复存在。其高效的原因有以下两点：</p>
<ol type="1">
<li>它通过使用<strong>红黑树</strong>这种数据结构来存储 epoll
所监听的套接字。当添加或者删除一个套接字时（epoll_ctl），都是在红黑树上进行处理，由于红黑树本身插入和删除性能比较好，时间复杂度为
O(logN)，因此其效率要高于 select/poll。</li>
<li>当把事件添加进来的时候时候会完成关键的一步，那就是该事件会与相应的设备（网卡）驱动程序建立回调关系，当相应的事件发生后，就会调用这个回调函数。这个回调函数其实就是把该事件添加到
<code>rdllist</code> 这个双向链表中。那么当我们调用 epoll_wait
时，epoll_wait 只需要检查 rdlist
双向链表中是否有存在注册的事件，效率非常可观。</li>
</ol>
<p>epoll 对文件描述符的操作有两种模式：LT（Level Trigger，电平触发）和
ET（Edge Trigger，边沿触发）模式。其中，LT
模式是默认的工作模式，这种模式下 epoll 相当于一个效率较高的 poll。当往
epoll 内核事件表中注册一个文件描述符上的 EPOLLOUT 事件时，epoll 将以 ET
模式来操作该文件描述符。ET 模式是 epoll 的高效工作模式。</p>
<p>对于采用 LT 工作模式的文件描述符，当 epoll_wait
检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用
epoll_wait 时，epoll_wait
还会再次向应用程序通告此事件，直到该事件被处理。而对于采用 ET
工作模式的文件描述符，当 epoll_wait
检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的
epoll_wait 调用将不再向应用程序通知这一事件。可见，ET
模式在很大程度上降低了同一个 epoll 事件被重复触发的此时，因此效率要比 LT
模式高。</p>
<p>在 muduo 网络库中，则采用了 LT 工作模式，其原因如下：</p>
<ol type="1">
<li>不会丢失数据或者消息，应用没有读取完数据，内核是会不断上报的；</li>
<li>每次读数据只需要一次系统调用；照顾了多个连接的公平性，不会因为某个连接上的数据量过大而影响其他连接处理消息；</li>
</ol>
<p>在 muduo 网络库中，借助于 Linux 下“一切皆文件”的思想，通过 epoll
进行管理的主要有如下三个类型的事件：</p>
<ul>
<li><strong>网络 I/O
事件</strong>：通过套接字（socket）文件描述符进行管理；</li>
<li><strong>线程通知事件</strong>：通过 eventfd 唤醒 SubLoop
处理相应的任务；</li>
<li><strong>定时器事件</strong>：通过 timerfd 来处理定时器事件；</li>
</ul>
<h2 id="qps">3. QPS</h2>
<p>QPS(Query Per Second) 即每秒查询率，QPS
是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p>
<p>未完成...</p>
<h1 id="日志模块">日志模块</h1>
<p>未完成...</p>
<h1 id="rpc模块">RPC模块</h1>
<p>RPC（Remote Procedure Call），即远程过程调用，也就是说两台服务器
A，B，一个应用部署在 A 服务器上，想要调用 B
服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。RPC
的主要功能目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。为实现该目标，RPC
框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用。</p>
<h2 id="分布式">1. 分布式</h2>
<p>考虑一个聊天业务，我们对其进行子模块划分，那么可以大致分为：用户管理、好友管理、群组管理、消息管理、文件管理，其中每一个模块都包含了一个特定的业务。将该服务器部署在一个单机上面，如下图所示：</p>
<p><img data-src="/images/apollo/single_server_model.png" width="40%" height="40%"/></p>
<p>上图中所示的单机服务器模型存在如下缺点：</p>
<ol type="1">
<li>受到硬件资源的限制，聊天服务器所能承受的用户的并发量较低；</li>
<li>修改任意模块的代码，会导致整个项目代码的重新编译、部署。项目如果过大，会很耗时；</li>
<li>在系统中，有些模块是属于 CPU 密集型的，而有些模块则是属于 I/O
密集型的，造成各个模块对于硬件资源的需求各不相同，而单机服务器只能给所有模块提供同一种硬件资源，无法做到硬件资源的特化；</li>
<li>如果服务器出现异常，那么整个服务都会挂掉；</li>
</ol>
<p>为了解决单机服务器所带来的并发量较低的缺陷，我们可以采用集群的方法，增加服务器的数量，同时通过一个负载均衡服务器来分发用户请求即可。常见的硬件负载均衡器有：F5、A10
等，软件层面的负载均衡服务器包括 LVS、Nginx、HAproxy
等。集群服务器模型的结构则如下图所示：</p>
<p><img data-src="/images/apollo/cluster_model.png" width="60%" height="60%"/></p>
<p>对于集群服务器模型而言，它解决了硬件资源受限所导致的用户并发量问题，此外如果其中一台服务器挂掉，还有另外其它几台服务器可以正常提供服务。但是对于项目编译、部署的问题而言，却并未得到改善，项目要分别在每个机器上进行编译、部署，反而变得更加麻烦了。对于不同模块对于硬件资源的需求也并未得到解决。此外，对于一些并发量较低的模块，可能并不需要做到高并发，也就无需通过负载均衡器将用户请求分发到不同的服务器中，但是对于集群模型而言，每一个模块之间都是均衡的，并未做到模块的特化。</p>
<p>为了改进上述缺点，我们需要将其改进为分布式模型，其结构如下图所示。即将不同的模块部署在不同的服务器上，同时对于并发量较大的模块，我们可以通过集群部署来提升它的并发量，此外对于不同的模块，也可以提供不同的硬件资源，同时修改一个模块的代码也无需再编译整个项目，仅仅编译该模块即可：</p>
<p><img data-src="/images/apollo/distributed_model.png" width="75%" height="75%"/></p>
<p>总结而言，集群和分布式的区别如下：</p>
<ul>
<li><strong>集群</strong>：每一台服务器独立运行一个工程的所有模块。</li>
<li><strong>分布式</strong>：一个工程拆分了很多模块，每一个模块独立部署运行在一个服务器主机上，所有服务器协同工
作共同提供服务，每一台服务器称作分布式的一个节点，根据节点的并发要求，对一个节点可以再做节点模块集群部署。</li>
</ul>
<h2 id="rpc">2. RPC</h2>
<p>尽管分布式模型存在许多优点，但是考虑如下场景：用户正在访问用户管理模块，此时需要获取所有的好友信息，那么需要用到好友管理模块的内容。但是由于分布式部署的原因，用户管理模块和好友管理模块部署在不同的两个分布式节点上，即两台主机上。此时用户管理主机应该如何调用好友管理主机上的相应的业务方法？</p>
<p>这时就需要使用到 RPC
方法，为使用者提供一种透明调用机制而不必显式的区分本地调用和远程调用。RPC
方法的交互过程如下图所示：</p>
<p><img data-src="/images/apollo/rpc_model.png"/></p>
<p>由于底层网络通信框架使用的是运输层协议，只能发送字节流，因此会涉及到对象的序列化/反序列化问题，即上图中所示的黄色部分，而常见的网络数据传输格式包括如下三种：</p>
<ul>
<li>XML：一种通用和轻量级的数据交换格式语言，是指可扩展标记语言以文本结构进行存储。</li>
<li>JSON：一种通用和轻量级的数据交换格式，也是以文本的结构进行存储，是一种简单的消息格式。JSON
作为数据包格式传输时具有更高的效率，这是因为 JSON 不像 XML
那样需要有严格的闭合标签，这就让有效数据量与总数据包比有着显著的提升，从而减少同等数据流量的情况下网络的传输压力。</li>
<li>Protobuf：是 Google
开发的一种独立和轻量级的数据交换格式，以二进制结构进行存储，用于不同服务之间序列化数据。它是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者序列化，可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</li>
</ul>
<p>而该项目便是使用 Protobuf
来进行消息的序列化和反序列化，同时使用其来实现RPC框架，其底层的通信流程如下图所示：</p>
<p><img data-src="/images/apollo/protobuf_process.png"/></p>
<p>此外，为了解决TCP的粘包问题，我们设计了如下格式的数据头用来传递服务名称、方法名称以及参数大小，通过该数据头部我们可以确定所要读取的数据长度：</p>
<figure class="highlight proto"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">RpcHeader</span> &#123;</span><br><span class="line">  <span class="type">bytes</span> service_name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">bytes</span> method_name = <span class="number">2</span>;</span><br><span class="line">  <span class="type">uint32</span> args_size = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，为了确定 RpcHeader 的长度，我们使用了固定的 4
个字节来存储消息头的长度。数据打包和解包的流程图如下所示：</p>
<p><img data-src="/images/apollo/pack_process.png"/></p>
<p><strong>打包流程</strong>：</p>
<ol type="1">
<li>序列化函数参数得到 argsStr，其长度为 argsSize；</li>
<li>打包 service_name、method_name 和 argsSize 得到 rpcHeader；</li>
<li>序列化 rpcHeader 得到 rpcHeaderStr，其长度为 headerSize；</li>
<li>将 headerSize 存储到数据包的前 4 个字节，后面的依次是 rpcHeaderStr
和 argsStr；</li>
<li>通过网络发送数据包；</li>
</ol>
<p><strong>解包流程</strong>：</p>
<ol type="1">
<li>通过网络接收数据包；</li>
<li>首先取出数据包的前 4 个字节，读取出 headerSize 的大小；</li>
<li>从第 5 个字节开始，读取 headerSize 字节大小的数据，即为 rpcHeaderStr
的内容；</li>
<li>反序列化 rpcHeaderStr，得到 service_name、method_name 和
argsSize；</li>
<li>从 4+headerSize 字节开始，读取 argsSize 字节大小的数据，即为 argsStr
的内容；</li>
<li>反序列化 argsStr 得到函数参数 args；</li>
</ol>
<h2 id="zookeeper">3. ZooKeeper</h2>
<p>在分布式应用中，为了能够知道自己所需的服务位于哪台主机上，我们需要一个服务注册与发现中心，这也就是该项目中的ZooKeeper。它是一种分布式协调服务，可以在分布式系统中共享配置，协调锁资源，提供命名服务。</p>
<p>Zookeeper通过树形结构来存储数据，它由一系列被称为<strong>ZNode</strong>的数据节点组成，类似于常见的文件系统。不过和常见的文件系统不同，Zookeeper将数据全量存储在内存中，以此来实现高吞吐，减少访问延迟，其结构如下图所示：</p>
<p><img data-src="/images/apollo/zookeeper_node.png" width="45%" height="45%"/></p>
<p>在 <code>ZkClient</code> 类中，调用 <code>start()</code> 方法创建
<code>zkHandler_</code> 句柄时，其调用过程如下图所示，由于
zookeeper_init
是异步方法，所以该函数返回后，并不代表句柄创建成功，它会在回调函数线程中调用所传入的回调函数，在该回调函数中我们可以来判断句柄是否创建成功，由于API调用线程阻塞于信号量处，所以在回调函数中如果句柄创建成功，则调用
<code>sem_post</code>
方法增加信号量，以通知API调用线程句柄创建成功：</p>
<p><img data-src="/images/apollo/zookeeper_process.png" width="50%" height="50%"/></p>
]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>内存池</tag>
        <tag>分布式</tag>
        <tag>异步日志</tag>
        <tag>网络通信</tag>
        <tag>Zookeeper</tag>
        <tag>protobuf</tag>
      </tags>
  </entry>
</search>
